<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seckinger Jaguars - GOLD Principle Offensive Line Blocking Schemes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #2d2d2d 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(23, 184, 190, 0.1);
            border: 2px solid #17b8be;
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(23, 184, 190, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            word-wrap: break-word;
            hyphens: auto;
            line-height: 1.2;
        }

        .team-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .team-header h1, .team-header h2 {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        /* Tutorial Tooltip Styles */
        .tutorial-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .diagram-container {
            position: relative;
        }

        .tutorial-button {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #17b8be;
            color: white;
            border: 2px solid #fff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .tutorial-button:hover {
            background: #20c997;
            transform: scale(1.1);
        }

        .tutorial-tooltip {
            position: absolute;
            top: 40px;
            right: 0;
            width: 320px;
            background: white;
            border: 2px solid #17b8be;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .tutorial-tooltip.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tutorial-tooltip h3 {
            color: #17b8be;
            margin: 0 0 10px 0;
            font-size: 16px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }

        .tutorial-tooltip ul {
            margin: 0;
            padding-left: 20px;
            font-size: 13px;
            color: #333;
        }

        .tutorial-tooltip li {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .tutorial-tooltip p {
            margin: 10px 0 0 0;
            font-size: 12px;
            color: #666;
            text-align: center;
            font-style: italic;
        }

        .gold-principle {
            background: linear-gradient(45deg, #17b8be, #20d0d7);
            color: #000;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 4px 15px rgba(23, 184, 190, 0.4);
            border: 2px solid #c0c0c0;
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-align: center;
        }

        .formation-btn, .play-btn {
            background: linear-gradient(45deg, #17b8be, #20d0d7);
            color: #000;
            border: 2px solid #c0c0c0;
            padding: 12px 20px;
            margin: 0 8px 8px 0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            touch-action: manipulation;
            -webkit-touch-callout: none;
            user-select: none;
            min-height: 44px;
            min-width: 44px;
        }

        .formation-btn:hover, .play-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(23, 184, 190, 0.6);
            background: linear-gradient(45deg, #20d0d7, #17b8be);
        }

        .formation-btn.active {
            background: linear-gradient(45deg, #000000, #1a1a1a);
            color: #17b8be;
            border: 2px solid #17b8be;
        }

        .play-btn {
            background: linear-gradient(45deg, #17b8be, #20d0d7);
            color: #000;
            border: 2px solid #c0c0c0;
        }

        .play-btn.active {
            background: linear-gradient(45deg, #000000, #1a1a1a);
            color: #17b8be;
            border: 2px solid #17b8be;
        }

        .diagram-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: inset 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .formation-title {
            color: #2c3e50;
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 30px;
            font-weight: bold;
        }

        .field {
            position: relative;
            width: 100%;
            min-height: 300px;
            background: #228B22;
            border: 3px solid #17b8be;
            border-radius: 10px;
            margin: 20px 0;
            background-image: 
                linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px),
                linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 50px 20px;
        }

        .gap-label {
            position: absolute;
            top: 75%;
            color: #FFD700;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 3;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .gap-label:hover {
            background: rgba(255, 215, 0, 0.8);
            color: #000;
            transform: scale(1.2);
        }

        .gap-label.selectable {
            background: rgba(255, 215, 0, 0.7);
            color: #000;
            animation: gapPulse 1s infinite;
        }

        @keyframes gapPulse {
            0% { background: rgba(255, 215, 0, 0.7); }
            50% { background: rgba(255, 215, 0, 1); }
            100% { background: rgba(255, 215, 0, 0.7); }
        }

        .line-of-scrimmage {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 3px;
            background: #FFD700;
            transform: translateY(-50%);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .player {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            border: 3px solid #fff;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .player:hover {
            z-index: 10;
        }



        .player.selectable-for-line {
            cursor: pointer;
            border-color: #28a745;
        }

        .player.selected-for-line {
            border-color: #FFD700 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
        }

        .linebacker {
            cursor: pointer;
            transition: all 0.5s ease;
        }

        .linebacker:hover {
            transform: scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .linebacker.blitzing {
            background: linear-gradient(45deg, #ff6b6b, #ff5252) !important;
            animation: blitzPulse 1s infinite;
        }

        .linebacker.selected {
            background: linear-gradient(45deg, #FFD700, #FFA500) !important;
            animation: selectedPulse 1s infinite;
            border-color: #FF4500 !important;
        }

        @keyframes selectedPulse {
            0% { transform: scale(1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
            50% { transform: scale(1.15); box-shadow: 0 0 25px rgba(255, 215, 0, 1); }
            100% { transform: scale(1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
        }

        @keyframes blitzPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .offensive-player {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .defensive-player {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .blocking-assignment {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }

        .assignment-line {
            stroke: #FFD700;
            stroke-width: 4;
            stroke-dasharray: 10, 5;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        .assignment-line.emphasis {
            stroke: #FF4500;
            stroke-width: 6;
            stroke-dasharray: 15, 5;
            animation: emphasize 2s infinite;
        }

        .assignment-line.fullback {
            stroke: rgba(138, 43, 226, 0.6); /* Transparent purple for FB */
            stroke-width: 3;
            stroke-dasharray: 5, 3;
            filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.2));
        }

        .assignment-arrow {
            fill: #FFD700;
            stroke: #B8860B;
            stroke-width: 1.5;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.4));
        }

        .assignment-arrow.fullback {
            fill: rgba(138, 43, 226, 0.9);
            stroke: rgba(75, 0, 130, 1);
            stroke-width: 2;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.4));
        }

        .assignment-arrow.emphasis {
            fill: #FF4500;
            stroke: #8B0000;
            stroke-width: 2.5;
            animation: emphasize 2s infinite;
            filter: drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.5));
        }
        
        /* Different arrow colors by block type */
        .assignment-arrow.gap {
            fill: #32CD32;
            stroke: #228B22;
            stroke-width: 2;
        }
        
        .assignment-arrow.on {
            fill: #FF6347;
            stroke: #DC143C;
            stroke-width: 2;
        }
        
        .assignment-arrow.linebacker {
            fill: #1E90FF;
            stroke: #0000CD;
            stroke-width: 2;
        }

        @keyframes emphasize {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            color: black;
            font-weight: bold;
        }

        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .legend-offensive {
            background: linear-gradient(45deg, #007bff, #0056b3);
        }

        .legend-defensive {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .explanation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(5px);
        }

        .explanation h3 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .explanation ul {
            list-style-position: inside;
            line-height: 1.6;
        }

        .explanation li {
            margin-bottom: 8px;
        }

        .highlight-mode {
            text-align: center;
            margin-top: 20px;
        }

        .highlight-btn {
            background: linear-gradient(45deg, #c0c0c0, #a0a0a0);
            color: #000;
            border: 2px solid #17b8be;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .highlight-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .highlighted {
            animation: pulse 1.5s infinite;
            border-color: #FFD700 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
            100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            body {
                padding: 5px;
            }
            
            .container {
                padding: 8px;
                margin: 0;
                border-radius: 8px;
            }
            
            h1 {
                font-size: 1.4em;
                margin-bottom: 5px;
            }
            
            .team-header {
                margin-bottom: 10px !important;
            }
            
            .team-header h2 {
                font-size: 0.9em;
                margin-bottom: 10px;
            }
            
            .tutorial-container {
                top: 10px;
                right: 10px;
            }
            
            .tutorial-button {
                width: 25px;
                height: 25px;
                font-size: 14px;
            }
            
            .tutorial-tooltip {
                width: 280px;
                padding: 12px;
                font-size: 12px;
            }
            
            .gold-principle {
                padding: 8px;
                font-size: 0.8em;
                margin-bottom: 15px;
            }
            
            .gold-principle h2 {
                font-size: 1em;
                margin-bottom: 5px;
            }
            
            .gold-principle p {
                margin-bottom: 8px;
                font-size: 0.85em;
            }
            
            .gold-principle div {
                flex-direction: column !important;
                gap: 5px !important;
                margin-top: 8px !important;
            }
            
            .gold-principle div > div {
                min-width: auto !important;
                margin-bottom: 5px;
                padding: 6px !important;
                font-size: 0.75em;
            }
            
            .controls {
                margin-bottom: 10px;
            }
            
            .control-section {
                margin-bottom: 8px;
            }
            
            .control-section h3 {
                font-size: 0.9em;
                margin-bottom: 5px;
                color: #ffc107;
            }
            
            .formation-btn, .play-btn {
                padding: 6px 10px;
                margin: 2px 1px;
                font-size: 0.7em;
                border-radius: 4px;
                min-height: 36px;
                min-width: 36px;
            }
            
            .diagram-container {
                padding: 8px;
            }
            
            .formation-title {
                font-size: 0.9em;
                margin-bottom: 8px;
            }
            
            .field {
                min-height: 200px;
                margin: 8px 0;
            }
            
            .player {
                width: 24px;
                height: 24px;
                font-size: 8px;
                border-width: 2px;
            }
            
            .gap-label {
                font-size: 10px;
                padding: 1px 3px;
            }
            
            .legend {
                flex-wrap: wrap;
                gap: 5px;
                justify-content: center;
                margin: 8px 0;
            }
            
            .legend-item {
                margin: 0 4px 4px 0;
                font-size: 0.7em;
            }
            
            .legend-circle {
                width: 12px;
                height: 12px;
            }
            
            .highlight-btn {
                padding: 4px 8px;
                margin: 1px;
                font-size: 0.7em;
                min-height: 32px;
                min-width: 32px;
            }
            
            .explanation {
                padding: 8px;
                font-size: 0.75em;
            }
            
            .explanation h3 {
                font-size: 0.9em;
                margin-bottom: 5px;
            }
            
            .explanation ul {
                margin-left: 10px;
            }
            
            .explanation li {
                margin-bottom: 3px;
                line-height: 1.3;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 3px;
            }
            
            .container {
                padding: 5px;
                border-radius: 6px;
            }
            
            h1 {
                font-size: 1.2em;
                margin-bottom: 3px;
            }
            
            .team-header h2 {
                font-size: 0.8em;
                margin-bottom: 8px;
            }
            
            .tutorial-tooltip {
                width: calc(100vw - 40px);
                max-width: 250px;
                padding: 10px;
                font-size: 11px;
                right: -10px;
            }
            
            .tutorial-button {
                width: 28px;
                height: 28px;
                font-size: 14px;
                min-width: 44px;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .gold-principle {
                padding: 6px;
                font-size: 0.7em;
                margin-bottom: 10px;
            }
            
            .gold-principle h2 {
                font-size: 0.9em;
                margin-bottom: 3px;
            }
            
            .gold-principle p {
                font-size: 0.75em;
                margin-bottom: 5px;
            }
            
            .gold-principle div > div {
                padding: 4px !important;
                font-size: 0.65em;
                margin-bottom: 3px;
            }
            
            .control-section h3 {
                font-size: 0.8em;
                margin-bottom: 3px;
            }
            
            .formation-btn, .play-btn {
                padding: 4px 8px;
                font-size: 0.65em;
                margin: 1px;
                min-height: 32px;
                min-width: 60px;
            }
            
            .field {
                min-height: 160px;
                margin: 5px 0;
            }
            
            .player {
                width: 20px;
                height: 20px;
                font-size: 7px;
                border-width: 1px;
            }
            
            .gap-label {
                font-size: 8px;
                padding: 1px 2px;
            }
            
            .highlight-btn {
                padding: 3px 6px;
                font-size: 0.6em;
                margin: 0.5px;
                min-height: 28px;
                min-width: 28px;
            }
            
            .legend-item {
                font-size: 0.6em;
                margin: 0 2px 2px 0;
            }
            
            .legend-circle {
                width: 10px;
                height: 10px;
            }
            
            .explanation {
                font-size: 0.65em;
                padding: 5px;
            }
            
            .explanation h3 {
                font-size: 0.8em;
                margin-bottom: 3px;
            }
            
            .explanation ul {
                margin-left: 8px;
            }
            
            .explanation li {
                margin-bottom: 2px;
                line-height: 1.2;
            }
        }

        /* Extra small devices (≤320px) */
        @media (max-width: 320px) {
            .tutorial-tooltip {
                width: calc(100vw - 20px);
                max-width: none;
                padding: 8px;
                font-size: 10px;
                right: -15px;
                left: -15px;
            }
            
            .tutorial-button {
                width: 26px;
                height: 26px;
                font-size: 12px;
                min-width: 44px;
                min-height: 44px;
            }
            
            .tutorial-tooltip ul {
                padding-left: 15px;
            }
            
            .tutorial-tooltip li {
                margin-bottom: 6px;
                line-height: 1.3;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="team-header" style="text-align: center;">
            <h1 style="color: #17b8be; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 5px; word-wrap: break-word; hyphens: auto;">🐆 SECKINGER JAGUARS</h1>
            <h2 style="color: #c0c0c0; font-size: 1.5em; margin-bottom: 20px; word-wrap: break-word; line-height: 1.3;">9U Offensive Line Blocking Schemes</h2>
        </div>
        

        
        <div class="gold-principle">
            <h2>GOLD Principle: Gap → On → Linebacker → (Closest to Ball)</h2>
            <p><em>"Take the most dangerous threat first, prioritize defenders closest to the gap/ball."</em></p>
            
            <div style="display: flex; gap: 15px; margin-top: 15px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 300px; padding: 10px; background: rgb(255, 255, 255); border-radius: 8px; border-left: 4px solid #ffc107;">
                    <strong>📍 PLAYSIDE (Ball Side):</strong><br>
                    Create movement and open the running lane<br>
                    • <strong>Gap:</strong> Immediate threat in your gap (blitzing LB)<br>
                    • <strong>On:</strong> Defender over you (head-up or shaded)<br>
                    • <strong>Linebacker:</strong> Help with linebacker<br>
                    • <strong>Closest:</strong> Take defender closest to the ball/gap
                </div>
                
                <div style="flex: 1; min-width: 300px; padding: 10px; background: rgb(255, 255, 255); border-radius: 8px; border-left: 4px solid #ffc107;">
                    <strong>🔒 BACKSIDE (Away from Ball):</strong><br>
                    Prevent pursuit and seal inside<br>
                    • <strong>Gap:</strong> Cut-off block, seal gap<br>
                    • <strong>On:</strong> Set and wall off<br>
                    • <strong>Linebacker:</strong> Prevent crossing face<br>
                    • <strong>Pursuit:</strong> Cut off defenders chasing the ball
                </div>
            </div>
            
            <div style="margin-top: 15px; padding: 10px; background: rgb(255, 255, 255); border-radius: 8px; border-left: 4px solid #FF4500; text-align: center;">
                <strong>🚨 KEY RULE:</strong> Always prioritize the defender closest to where the ball is going!
            </div>
        </div>

        <div class="controls">
            <div class="control-section">
                <h3>Defensive Formation:</h3>
                <button class="formation-btn active" data-formation="3-4">3-4</button>
                <button class="formation-btn" data-formation="4-3">4-3</button>
                <button class="formation-btn" data-formation="4-4">4-4</button>
                <button class="formation-btn" data-formation="5-2">5-2</button>
                <button class="formation-btn" data-formation="5-3">5-3</button>
                <button class="formation-btn" data-formation="6-2">6-2</button>
            </div>
            
            <div class="control-section">
                <h3>Play Type:</h3>
                <button class="play-btn active" data-play="1-gap">1 Gap</button>
                <button class="play-btn" data-play="2-gap">2 Gap</button>
                <button class="play-btn" data-play="3-gap">3 Gap</button>
                <button class="play-btn" data-play="4-gap">4 Gap</button>
                <button class="play-btn" data-play="5-gap">5 Gap</button>
                <button class="play-btn" data-play="6-gap">6 Gap</button>
                <button class="play-btn" data-play="7-gap">7 Gap</button>
                <button class="play-btn" data-play="pass-pro">Pass Pro</button>
            </div>
            

        </div>

        <div class="diagram-container">
            <div class="formation-title" id="formation-title">Vs. 4-4 Defense - Inside Zone</div>
            
            <!-- Tutorial Tooltip -->
            <div class="tutorial-container">
                <button class="tutorial-button" onclick="toggleTutorial()">?</button>
                <div class="tutorial-tooltip" id="tutorialTooltip">
                    <h3>How to Use This Diagram</h3>
                    <ul>
                        <li><strong>Select Formation:</strong> Choose defensive front (3-4, 4-3, etc.)</li>
                        <li><strong>Choose Play:</strong> Pick gap run (1-7) or Pass Pro</li>
                        <li><strong>Highlight Players:</strong> Click TE, LT, LG, C, RG, RT to focus</li>
                        <li><strong>Simulate Blitz:</strong> Click LB/HYB → Click gap to move them</li>
                        <li><strong>Manual Lines:</strong> Toggle "Draw Lines" → Click OL → Click defender</li>
                        <li><strong>Reset:</strong> "Reset All" clears everything</li>
                    </ul>
                </div>
            </div>
            
            <div class="field" id="field">
                <div class="line-of-scrimmage"></div>
                <svg class="blocking-assignment" id="blocking-lines" width="100%" height="100%"></svg>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle legend-offensive"></div>
                    <span>Offense</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle legend-defensive"></div>
                    <span>Defense</span>
                </div>
                <div class="legend-item">
                    <div style="width: 20px; height: 3px; background: #FFD700;"></div>
                    <span>Assignments</span>
                </div>
            </div>

            <div class="highlight-mode">
                <button class="highlight-btn" data-position="TE">TE</button>
                <button class="highlight-btn" data-position="FB">FB</button>
                <button class="highlight-btn" data-position="LT">LT</button>
                <button class="highlight-btn" data-position="LG">LG</button>
                <button class="highlight-btn" data-position="C">C</button>
                <button class="highlight-btn" data-position="RG">RG</button>
                <button class="highlight-btn" data-position="RT">RT</button>
                <button class="highlight-btn" onclick="toggleLineMode()" id="line-mode-toggle" style="background: linear-gradient(45deg, #28a745, #20c997);">Draw Lines</button>
                <button class="highlight-btn" onclick="resetAll()" style="background: linear-gradient(45deg, #ff6b6b, #ff5252);">Reset All</button>
            </div>
        </div>

        <div class="explanation" id="explanation">
            <h3>4-4 Defense Blocking Rules:</h3>
            <ul>
                <li><strong>Center (C):</strong> Block middle linebacker (M). Identify the "Mike" linebacker and secure the A-gap first.</li>
                <li><strong>Guards (G):</strong> Check A-gap first, then work to linebacker level. Communication with center is key.</li>
                <li><strong>Tackles (T):</strong> Block defensive ends (DE). Set with outside foot, keep them from rushing outside.</li>
                <li><strong>Key Teaching Points:</strong> Eyes up, stay low, work together as a unit, and always secure the inside gaps first!</li>
            </ul>
        </div>
    </div>

    <script>
        // Play type data with emphasis and coaching points
        const playTypes = {
            '1-gap': {
                name: '1 Gap (LEFT A-Gap)',
                emphasis: 'PLAYSIDE: LG/C drive blocks • BACKSIDE: RG/RT cut-off pursuit',
                emphasisLevel: ['gap'], // A-gap control critical
                description: 'Left A-gap run - playside creates hole, backside seals inside',
                targetGap: '1',
                side: 'left'
            },
            '2-gap': {
                name: '2 Gap (RIGHT A-Gap)', 
                emphasis: 'PLAYSIDE: RG/C drive blocks • BACKSIDE: LG/LT cut-off pursuit',
                emphasisLevel: ['gap'], // A-gap control critical
                description: 'Right A-gap run - playside creates hole, backside seals inside',
                targetGap: '2',
                side: 'right'
            },
            '3-gap': {
                name: '3 Gap (LEFT B-Gap)',
                emphasis: 'PLAYSIDE: LG/LT drive blocks • BACKSIDE: RG/RT seal inside',
                emphasisLevel: ['gap', 'on'], // B-gap control and blocks
                description: 'Left B-gap run - playside attacks, backside prevents pursuit',
                targetGap: '3',
                side: 'left'
            },
            '4-gap': {
                name: '4 Gap (RIGHT B-Gap)',
                emphasis: 'PLAYSIDE: RG/RT drive blocks • BACKSIDE: LG/LT seal inside',
                emphasisLevel: ['gap', 'on'], // B-gap control and blocks
                description: 'Right B-gap run - playside attacks, backside prevents pursuit',
                targetGap: '4',
                side: 'right'
            },
            '5-gap': {
                name: '5 Gap (LEFT C-Gap)',
                emphasis: 'Left Tackle seals LEFT C-gap outside!',
                emphasisLevel: ['on', 'down'], // Tackle blocks critical
                description: 'Run LEFT outside the left tackle - seal inside pursuit',
                targetGap: '5',
                side: 'left'
            },
            '6-gap': {
                name: '6 Gap (RIGHT C-Gap)',
                emphasis: 'Right Tackle seals RIGHT C-gap outside!',
                emphasisLevel: ['on', 'down'], // Tackle blocks critical
                description: 'Run RIGHT outside the right tackle - seal inside pursuit',
                targetGap: '6',
                side: 'right'
            },
            '7-gap': {
                name: '7 Gap (LEFT D-Gap)',
                emphasis: 'Backside LEFT - cut off all pursuit!',
                emphasisLevel: ['down'], // Down blocks to seal backside
                description: 'LEFT outside run - backside must cut off pursuit',
                targetGap: '7',
                side: 'left'
            },
            'pass-pro': {
                name: 'Pass Protection',
                emphasis: 'Set, anchor, and protect the pocket - TE runs GO ROUTE!',
                emphasisLevel: ['gap', 'on'], // Gap control and anchor blocks critical
                description: 'OL: Vertical set, hands inside, keep QB clean • TE: Release on go route',
                targetGap: 'pass',
                side: 'both'
            }
        };

        // Formation data with player positions and blocking assignments
        const formations = {
            '4-3': {
                title: 'Vs. 4-3 Defense',
                offensive: [
                    { id: 'LT', pos: 'LT', x: 20, y: 60, label: 'LT' },
                    { id: 'LG', pos: 'LG', x: 35, y: 60, label: 'LG' },
                    { id: 'C', pos: 'C', x: 50, y: 60, label: 'C' },
                    { id: 'RG', pos: 'RG', x: 65, y: 60, label: 'RG' },
                    { id: 'RT', pos: 'RT', x: 80, y: 60, label: 'RT' }
                ],
                defensive: [
                    // Defensive Line (4 down linemen)
                    { id: 'DE1', x: 15, y: 40, label: 'DE' },
                    { id: 'DT1', x: 35, y: 40, label: 'DT' },
                    { id: 'DT2', x: 65, y: 40, label: 'DT' },
                    { id: 'DE2', x: 85, y: 40, label: 'DE' },
                    // Linebackers (3 linebackers)
                    { id: 'WLB', x: 25, y: 25, label: 'LB' }, // Weak-side LB
                    { id: 'MLB', x: 50, y: 25, label: 'LB' }, // Middle LB
                    { id: 'SLB', x: 75, y: 25, label: 'LB' }  // Strong-side LB
                ],
                assignments: [
                    { from: 'LT', to: 'DE1', type: 'on' },
                    { from: 'LG', to: 'DT1', type: 'on' },
                    { from: 'C', to: 'MLB', type: 'linebacker' },
                    { from: 'RG', to: 'DT2', type: 'on' },
                    { from: 'RT', to: 'DE2', type: 'on' }
                ],
                explanation: {
                    title: '4-3 Defense Blocking Rules:',
                    points: [
                        '<strong>RULE #1:</strong> Guards and Tackles have defensive linemen over them - block them first!',
                        '<strong>Left Tackle (LT):</strong> GOLD Rule - DE1 is on you, so block him (On rule).',
                        '<strong>Left Guard (LG):</strong> GOLD Rule - DT1 is on you, so block him (On rule).',
                        '<strong>Center (C):</strong> GOLD Rule - No gap threat, no one on you, so take MLB (Linebacker rule).',
                        '<strong>Right Guard (RG):</strong> GOLD Rule - DT2 is on you, so block him (On rule).',
                        '<strong>Right Tackle (RT):</strong> GOLD Rule - DE2 is on you, so block him (On rule).',
                        '<strong>Key Teaching Points:</strong> 4-3 leaves center free to work on middle linebacker!'
                    ]
                }
            },
            '3-4': {
                title: "Vs. 3-4 Defense",
                offensive: [
                    { id: 'LT', pos: 'LT', x: 20, y: 60, label: 'LT' },
                    { id: 'LG', pos: 'LG', x: 35, y: 60, label: 'LG' },
                    { id: 'C', pos: 'C', x: 50, y: 60, label: 'C' },
                    { id: 'RG', pos: 'RG', x: 65, y: 60, label: 'RG' },
                    { id: 'RT', pos: 'RT', x: 80, y: 60, label: 'RT' }
                ],
                defensive: [
                    // Defensive Line (3 down linemen)
                    { id: 'DE1', x: 25, y: 40, label: 'DE' },
                    { id: 'NG', x: 50, y: 40, label: 'NG' },   // Nose Guard over center
                    { id: 'DE2', x: 75, y: 40, label: 'DE' },
                    // Outside Linebackers (edge rushers at line of scrimmage)
                    { id: 'OLB1', x: 10, y: 40, label: 'OLB' }, // Outside LB (edge rusher)
                    { id: 'OLB2', x: 90, y: 40, label: 'OLB' }, // Outside LB (edge rusher)
                    // Inside Linebackers (true linebackers)
                    { id: 'ILB1', x: 35, y: 25, label: 'LB' }, // Inside LB
                    { id: 'ILB2', x: 65, y: 25, label: 'LB' }  // Inside LB
                ],
                assignments: [
                    { from: 'LT', to: 'OLB1', type: 'on' },
                    { from: 'LG', to: 'DE1', type: 'on' },
                    { from: 'C', to: 'NG', type: 'on' },
                    { from: 'RG', to: 'DE2', type: 'on' },
                    { from: 'RT', to: 'OLB2', type: 'on' }
                ],
                explanation: {
                    title: '3-4 Defense Blocking Rules:',
                    points: [
                        '<strong>RULE #1:</strong> In 3-4, everyone has a man! OLBs are edge rushers, DEs are inside.',
                        '<strong>Left Tackle (LT):</strong> GOLD Rule - OLB1 is your edge rusher, set and anchor (On rule).',
                        '<strong>Left Guard (LG):</strong> GOLD Rule - DE1 is on you, drive block him (On rule).',
                        '<strong>Center (C):</strong> GOLD Rule - Nose Guard is head-up, control him first (On rule).',
                        '<strong>Right Guard (RG):</strong> GOLD Rule - DE2 is on you, drive block him (On rule).',
                        '<strong>Right Tackle (RT):</strong> GOLD Rule - OLB2 is your edge rusher, set and anchor (On rule).',
                        '<strong>Key Teaching Points:</strong> 3-4 puts 5 rushers on 5 blockers - everyone must win their 1-on-1!'
                    ]
                }
            },
            '4-4': {
                title: 'Vs. 4-4 Defense',
                offensive: [
                    { id: 'LT', pos: 'LT', x: 20, y: 60, label: 'LT' },
                    { id: 'LG', pos: 'LG', x: 35, y: 60, label: 'LG' },
                    { id: 'C', pos: 'C', x: 50, y: 60, label: 'C' },
                    { id: 'RG', pos: 'RG', x: 65, y: 60, label: 'RG' },
                    { id: 'RT', pos: 'RT', x: 80, y: 60, label: 'RT' }
                ],
                defensive: [
                    { id: 'DE1', x: 15, y: 40, label: 'DE' },
                    { id: 'DT1', x: 35, y: 40, label: 'DT' },
                    { id: 'DT2', x: 65, y: 40, label: 'DT' },
                    { id: 'DE2', x: 85, y: 40, label: 'DE' },
                    { id: 'LB1', x: 20, y: 25, label: 'LB' },
                    { id: 'LB2', x: 40, y: 25, label: 'LB' },
                    { id: 'LB3', x: 60, y: 25, label: 'LB' },
                    { id: 'LB4', x: 80, y: 25, label: 'LB' }
                ],
                assignments: [
                    { from: 'LT', to: 'DE1', type: 'on' },
                    { from: 'LG', to: 'DT1', type: 'on' },  // DT over LG - take him first
                    { from: 'C', to: 'LB3', type: 'gap' },  // LB in center's inside gap - GOLD rule #1
                    { from: 'RG', to: 'DT2', type: 'on' },  // DT over RG - take him first
                    { from: 'RT', to: 'DE2', type: 'on' }
                ],
                explanation: {
                    title: '4-4 Defense Blocking Rules:',
                    points: [
                        '<strong>RULE #1:</strong> If a defender is over you (head-up or shaded), you MUST block him first!',
                        '<strong>Guards (G):</strong> DT is over you - drive block him. Don\'t go to linebacker until DT is controlled.',
                        '<strong>Center (C):</strong> GOLD Rule - LB3 is in your inside gap, so block him first (Gap rule).',
                        '<strong>Tackles (T):</strong> Block defensive ends. They\'re over you, so that\'s your man.',
                        '<strong>Key Teaching Points:</strong> Man over you = YOUR responsibility. Linebacker is secondary!'
                    ]
                }
            },
            '5-2': {
                title: 'Vs. 5-2 Defense',
                offensive: [
                    { id: 'LT', pos: 'LT', x: 20, y: 60, label: 'LT' },
                    { id: 'LG', pos: 'LG', x: 35, y: 60, label: 'LG' },
                    { id: 'C', pos: 'C', x: 50, y: 60, label: 'C' },
                    { id: 'RG', pos: 'RG', x: 65, y: 60, label: 'RG' },
                    { id: 'RT', pos: 'RT', x: 80, y: 60, label: 'RT' }
                ],
                defensive: [
                    { id: 'DE1', x: 15, y: 40, label: 'DE' },
                    { id: 'DT1', x: 35, y: 40, label: 'DT' },
                    { id: 'NG', x: 50, y: 40, label: 'NG' },
                    { id: 'DT2', x: 65, y: 40, label: 'DT' },
                    { id: 'DE2', x: 85, y: 40, label: 'DE' },
                    { id: 'LB1', x: 35, y: 25, label: 'LB' },
                    { id: 'LB2', x: 65, y: 25, label: 'LB' }
                ],
                assignments: [
                    { from: 'LT', to: 'DE1', type: 'on' },
                    { from: 'LG', to: 'LB1', type: 'linebacker' },
                    { from: 'C', to: 'NG', type: 'on' },
                    { from: 'RG', to: 'LB2', type: 'linebacker' },
                    { from: 'RT', to: 'DE2', type: 'on' }
                ],
                explanation: {
                    title: '5-2 Defense Blocking Rules:',
                    points: [
                        '<strong>RULE #1:</strong> If a defender is over you (head-up or shaded), you MUST block him first!',
                        '<strong>Center (C):</strong> Nose guard is over you - that\'s YOUR man. Control him first, always.',
                        '<strong>Guards (G):</strong> No one directly over you, so work to linebackers. Help center if nose guard penetrates.',
                        '<strong>Tackles (T):</strong> Defensive ends are over you - block them. Don\'t let them rush outside.',
                        '<strong>Key Teaching Points:</strong> Center has the hardest job - nose guard is his responsibility!'
                    ]
                }
            },
            '5-3': {
                title: 'Vs. 5-3 Defense',
                offensive: [
                    { id: 'LT', pos: 'LT', x: 20, y: 60, label: 'LT' },
                    { id: 'LG', pos: 'LG', x: 35, y: 60, label: 'LG' },
                    { id: 'C', pos: 'C', x: 50, y: 60, label: 'C' },
                    { id: 'RG', pos: 'RG', x: 65, y: 60, label: 'RG' },
                    { id: 'RT', pos: 'RT', x: 80, y: 60, label: 'RT' }
                ],
                defensive: [
                    { id: 'DE1', x: 15, y: 40, label: 'DE' },
                    { id: 'DT1', x: 35, y: 40, label: 'DT' },
                    { id: 'NG', x: 50, y: 40, label: 'NG' },
                    { id: 'DT2', x: 65, y: 40, label: 'DT' },
                    { id: 'DE2', x: 85, y: 40, label: 'DE' },
                    { id: 'LB1', x: 25, y: 25, label: 'LB' },
                    { id: 'LB2', x: 50, y: 25, label: 'LB' },
                    { id: 'LB3', x: 75, y: 25, label: 'LB' }
                ],
                assignments: [
                    { from: 'LT', to: 'DE1', type: 'on' },
                    { from: 'LG', to: 'LB1', type: 'linebacker' },  // No DT over LG, go to LB
                    { from: 'C', to: 'NG', type: 'on' },  // Nose guard over center - block him first
                    { from: 'RG', to: 'LB3', type: 'linebacker' },  // No DT over RG, go to LB
                    { from: 'RT', to: 'DE2', type: 'on' }
                ],
                explanation: {
                    title: '5-3 Defense Blocking Rules:',
                    points: [
                        '<strong>RULE #1:</strong> If a defender is over you (head-up or shaded), you MUST block him first!',
                        '<strong>Center (C):</strong> Nose guard over you - block him first. Then help or work to linebacker.',
                        '<strong>Guards (G):</strong> Check if DT is over you. If yes, block him. If no, work to linebacker.',
                        '<strong>Tackles (T):</strong> Defensive ends are over you - that\'s your assignment.',
                        '<strong>Key Teaching Points:</strong> Lots of bodies inside - know who\'s over you vs. who\'s in the gap!'
                    ]
                }
            },
            '6-2': {
                title: 'Vs. 6-2 Defense',
                offensive: [
                    { id: 'LT', pos: 'LT', x: 20, y: 60, label: 'LT' },
                    { id: 'LG', pos: 'LG', x: 35, y: 60, label: 'LG' },
                    { id: 'C', pos: 'C', x: 50, y: 60, label: 'C' },
                    { id: 'RG', pos: 'RG', x: 65, y: 60, label: 'RG' },
                    { id: 'RT', pos: 'RT', x: 80, y: 60, label: 'RT' }
                ],
                defensive: [
                    { id: 'DE1', x: 15, y: 40, label: 'DE' },
                    { id: 'DT1', x: 30, y: 40, label: 'DT' },
                    { id: 'NG', x: 50, y: 40, label: 'NG' },
                    { id: 'DT2', x: 70, y: 40, label: 'DT' },
                    { id: 'DE2', x: 85, y: 40, label: 'DE' },
                    { id: 'OLB1', x: 10, y: 40, label: 'OLB' },
                    { id: 'LB1', x: 35, y: 25, label: 'LB' },
                    { id: 'LB2', x: 65, y: 25, label: 'LB' }
                ],
                assignments: [
                    { from: 'LT', to: 'DT1', type: 'down' },
                    { from: 'LG', to: 'LB1', type: 'linebacker' },
                    { from: 'C', to: 'NG', type: 'on' },
                    { from: 'RG', to: 'LB2', type: 'linebacker' },
                    { from: 'RT', to: 'DT2', type: 'down' }
                ],
                explanation: {
                    title: '6-2 Defense Blocking Rules:',
                    points: [
                        '<strong>RULE #1:</strong> If a defender is over you (head-up or shaded), you MUST block him first!',
                        '<strong>Center (C):</strong> Nose guard over you - block him. Don\'t let him penetrate!',
                        '<strong>Guards (G):</strong> No one over you, so work to linebackers. Watch for blitzing LBs.',
                        '<strong>Tackles (T):</strong> DT is over you - drive block him inside. Don\'t let him penetrate.',
                        '<strong>Key Teaching Points:</strong> Lots of linemen - everyone has someone over them except guards!'
                    ]
                }
            }
        };

        let currentFormation = '3-4';
        let currentPlayType = '1-gap';
        let highlightedPositions = [];
        let blitzingLinebackers = new Set(); // Track which LBs are blitzing
        let selectedLBForBlitz = null; // Track which LB is selected to move
        let showAssignmentLines = true; // Track if assignment lines are visible
        let manualLineMode = false; // Track if manual line drawing is enabled
        let selectedPlayerForLine = null; // Track selected player for manual line
        let manualLines = []; // Store manually drawn lines

        // Constants for consistent distance calculations
        const DISTANCE_THRESHOLDS = {
            OVER_PLAYER: 8,        // Defender is "over" an offensive player
            CLOSE_THREAT: 12,      // Close enough to be immediate threat
            PLAYSIDE_HELP: 20,     // Within range for linebacker help
            BLITZ_DETECTION: 8     // Distance to detect blitzing linebacker
        };

        // Initialize the diagram
        function init() {
            renderFormation(currentFormation, currentPlayType);
            setupEventListeners();
            updateFBButtonState(); // Set initial FB button state
        }

        // Set up event listeners
        function setupEventListeners() {
            // Formation buttons
            document.querySelectorAll('.formation-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const formation = e.target.dataset.formation;
                    switchFormation(formation);
                });
            });

            // Play type buttons
            document.querySelectorAll('.play-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const playType = e.target.dataset.play;
                    switchPlayType(playType);
                });
            });

            // Highlight buttons
            document.querySelectorAll('.highlight-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const position = e.target.dataset.position;
                    highlightPosition(position);
                });
            });
            

        }

        // Switch between formations
        function switchFormation(formation) {
            currentFormation = formation;
            
            // Clean up state when switching formations
            cleanupGlobalState();
            
            // Update active button
            document.querySelectorAll('.formation-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-formation="${formation}"]`).classList.add('active');
            
            renderFormation(formation, currentPlayType);
        }

        // Switch between play types
        function switchPlayType(playType) {
            const previousPlayData = playTypes[currentPlayType];
            const newPlayData = playTypes[playType];
            
            // Check if strong side is changing
            if (previousPlayData && previousPlayData.side !== newPlayData.side) {
                console.log(`🔄 Strong side changing from ${previousPlayData.side} to ${newPlayData.side} - clearing blitz data`);
                
                // Clear all blitz data since HYB is moving to opposite side
                blitzingLinebackers.clear();
                selectedLBForBlitz = null;
                if (window.customBlitzPositions) {
                    window.customBlitzPositions.clear();
                }
                window.updatedAssignments = null;
                
                // Clear manual line data as well
                manualLines = [];
                selectedPlayerForLine = null;
            }
            
            currentPlayType = playType;
            
            // Update active button
            document.querySelectorAll('.play-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-play="${playType}"]`).classList.add('active');
            
            // Update FB button availability
            updateFBButtonState();
            
            renderFormation(currentFormation, playType);
        }

        // Update FB button state based on play type
        function updateFBButtonState() {
            const fbButton = document.querySelector('[data-position="FB"]');
            const currentPlay = playTypes[currentPlayType];
            
            if (fbButton) {
                if (currentPlay.targetGap === 'pass') {
                    fbButton.style.opacity = '0.3';
                    fbButton.style.cursor = 'not-allowed';
                    fbButton.title = 'FB only available on run plays (gaps 1-4)';
                } else {
                    fbButton.style.opacity = '1';
                    fbButton.style.cursor = 'pointer';
                    fbButton.title = 'Highlight Fullback';
                }
            }
        }


        // Render the formation
        function renderFormation(formation, playType) {
            const data = formations[formation];
            const playData = playTypes[playType];
            const field = document.getElementById('field');
            const title = document.getElementById('formation-title');
            const explanation = document.getElementById('explanation');
            
            // Update title
            title.textContent = `${data.title} - ${playData.name}`;
            
            // Clear existing players, gap labels, and any leftover SVG elements
            field.querySelectorAll('.player, .gap-label').forEach(element => element.remove());
            
            // Ensure SVG is completely cleared
            const svg = document.getElementById('blocking-lines');
            if (svg) {
                svg.innerHTML = '';
            }
            
            // Add offensive players
            data.offensive.forEach(player => {
                const playerEl = createPlayer(player, 'offensive-player');
                field.appendChild(playerEl);
            });
            
            // Add tight end on the side of the gap
            const tightEnd = addTightEnd(playData.side, playData.targetGap);
            if (tightEnd) {
                const teEl = createPlayer(tightEnd, 'offensive-player');
                field.appendChild(teEl);
            }
            
            // Add fullback behind center
            const fullback = addFullback(playData.side, playData.targetGap);
            if (fullback) {
                const fbEl = createPlayer(fullback, 'offensive-player');
                field.appendChild(fbEl);
            }
            
            // Create defensive array with Hybrid defender on strong side
            let allDefensive = [...data.defensive];
            
            // Add Hybrid defender on strong side (where TE is)
            let hybridDefender = null; // Declare here for later use
            if (tightEnd) {
                hybridDefender = createHybridDefender(playData.side);
                if (hybridDefender) {
                    allDefensive.push(hybridDefender);
                    console.log(`🎯 Added HYB defender on ${playData.side} side (strong side):`, hybridDefender); // Debug
                }
            }
            
            // Add defensive players
            allDefensive.forEach(player => {
                const playerEl = createPlayer(player, 'defensive-player');
                
                // If this LB or HYB is blitzing, position them in the gap instead
                if ((player.label === 'LB' || player.id === 'HYB') && blitzingLinebackers.has(player.id)) {
                    const blitzPosition = getBlitzPosition(player);
                    playerEl.style.left = `${blitzPosition.x}%`;
                    playerEl.style.top = `${blitzPosition.y}%`;
                    playerEl.classList.add('blitzing');
                }
                
                // Special styling for Hybrid defender
                if (player.id === 'HYB') {
                    playerEl.style.background = 'linear-gradient(45deg, #ffc107, #ff8f00)';
                    playerEl.style.border = '3px solid #ff6f00';
                    playerEl.style.fontWeight = 'bold';
                    playerEl.title = `HYB - Hybrid Defender (Nickel/Safety/Rover) - Strong Side`;
                }
                
                field.appendChild(playerEl);
            });
            
            // Add gap labels
            addGapLabels(field, playData.targetGap);
            
            // Generate play-direction specific blocking assignments
            const allOffensive = [...data.offensive];
            if (tightEnd) allOffensive.push(tightEnd);
            if (fullback) allOffensive.push(fullback);
            
            // Get blocking assignments based on play direction (include Star defender)
            const playDirectionAssignments = getPlayDirectionAssignments(
                allOffensive, 
                allDefensive, 
                playData.side, 
                playData.targetGap
            );
            
            // Draw or clear assignments based on toggle
            if (showAssignmentLines) {
                // Use updated assignments if available (after LB blitz), otherwise use calculated ones
                const assignmentsToUse = window.updatedAssignments || playDirectionAssignments;
                if (window.updatedAssignments) {
                    console.log('Using updated assignments:', window.updatedAssignments); // Debug
                } else {
                    console.log('Using original assignments:', playDirectionAssignments); // Debug
                }
                // Create updated defensive array with blitzed LB positions
                const updatedDefensiveForDrawing = data.defensive.map(defender => {
                    // Check if this linebacker has a custom blitz position
                    if (window.customBlitzPositions && window.customBlitzPositions.has(defender.id)) {
                        const blitzPos = window.customBlitzPositions.get(defender.id);
                        console.log(`📍 Using blitz position for ${defender.id}:`, blitzPos); // Debug
                        return { ...defender, x: blitzPos.x, y: blitzPos.y };
                    }
                    return defender;
                });
                
                // Add the HYB defender if it exists (dynamically created)
                if (hybridDefender) {
                    // Check if HYB is blitzing
                    if (window.customBlitzPositions && window.customBlitzPositions.has(hybridDefender.id)) {
                        const blitzPos = window.customBlitzPositions.get(hybridDefender.id);
                        console.log(`📍 Adding blitzing HYB to drawing array:`, blitzPos); // Debug
                        updatedDefensiveForDrawing.push({ ...hybridDefender, x: blitzPos.x, y: blitzPos.y });
                    } else {
                        console.log(`📍 Adding normal HYB to drawing array`); // Debug
                        updatedDefensiveForDrawing.push(hybridDefender);
                    }
                }
                
                drawBlockingAssignments(assignmentsToUse, allOffensive, updatedDefensiveForDrawing, playData.emphasisLevel);
                
                // Draw TE route if it's pass protection
                if (playData.targetGap === 'pass' && tightEnd) {
                    drawTERoute(tightEnd);
                }
            } else {
                // Clear the SVG when lines are hidden
                const svg = document.getElementById('blocking-lines');
                svg.innerHTML = '';
                
                // Draw manual lines if any exist
                drawManualLines();
            }
            
            // Update explanation with play-specific info
            updateExplanationWithPlayType(data.explanation, playData);
        }

        // Add tight end on the side of the gap
        function addTightEnd(side, targetGap) {
            // For pass protection, add TE on right side (help with blitz pickup)
            if (targetGap === 'pass') {
                return { id: 'RTE', pos: 'RTE', x: 88, y: 60, label: 'TE' };
            }
            
            let tePosition;
            if (side === 'left') {
                // Left side TE - right next to LT (LT is at 20%)
                tePosition = { id: 'LTE', pos: 'LTE', x: 12, y: 60, label: 'TE' };
            } else {
                // Right side TE - right next to RT (RT is at 80%)
                tePosition = { id: 'RTE', pos: 'RTE', x: 88, y: 60, label: 'TE' };
            }
            
            return tePosition;
        }

        // Add fullback for run plays to help with linebacker pickup
        function addFullback(side, targetGap) {
            // Only add FB for run plays, not pass protection
            if (targetGap === 'pass') {
                return null;
            }
            
            // FB positioned behind center (where QB was)
            return { id: 'FB', pos: 'FB', x: 50, y: 80, label: 'FB' };
        }

        // Get formation-aware blocking assignments that adapt to linebacker movement
        function getPlayDirectionAssignments(offensive, defensive, playSide, targetGap) {
            // PASS PROTECTION - Different rules entirely
            if (targetGap === 'pass') {
                return getFormationSpecificPassProtection(offensive, defensive);
            }
            
            // Use formation-specific logic
            return getFormationSpecificAssignments(offensive, defensive, playSide, targetGap);
        }
        
        // Get formation-specific blocking assignments
        function getFormationSpecificAssignments(offensive, defensive, playSide, targetGap) {
            const assignments = [];
            
            // Get offensive players by position
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Detect formation type based on defensive structure
            const formationType = detectFormationType(defensive);
            console.log(`🏈 Detected formation: ${formationType}`); // Debug
            
            // Use formation-specific assignment logic
            switch (formationType) {
                case '4-3':
                    return get43Assignments(offensive, defensive, playSide, assignments, targetGap);
                case '3-4':
                    return get34Assignments(offensive, defensive, playSide, assignments, targetGap);
                case '4-4':
                    return get44Assignments(offensive, defensive, playSide, assignments, targetGap);
                case '5-2':
                    return get52Assignments(offensive, defensive, playSide, assignments, targetGap);
                case '5-3':
                    return get53Assignments(offensive, defensive, playSide, assignments);
                case '6-2':
                    return get62Assignments(offensive, defensive, playSide, assignments);
                default:
                    // Fallback to generic logic
                    return getGenericAssignments(offensive, defensive, playSide, assignments);
            }
        }
        
        // Detect formation type based on defensive player IDs and positions
        function detectFormationType(defensive) {
            // Check for specific player IDs that identify formations
            if (defensive.some(d => d.id === 'MLB')) return '4-3';
            if (defensive.some(d => d.id === 'ILB1') && defensive.some(d => d.id === 'ILB2')) return '3-4';
            if (defensive.some(d => d.id === 'LB1') && defensive.some(d => d.id === 'LB4')) return '4-4';
            if (defensive.some(d => d.id === 'NG') && defensive.filter(d => d.label === 'LB').length === 2) return '5-2';
            if (defensive.some(d => d.id === 'NG') && defensive.filter(d => d.label === 'LB').length === 3) return '5-3';
            if (defensive.filter(d => d.label === 'DT').length >= 4) return '6-2';
            
            return 'generic'; // Fallback
        }
        
        // Add assignment validation function
        function validateAssignments(assignments, defensive) {
            const issues = [];
            const assignedDefenders = new Set();
            
            // Check for duplicate assignments
            assignments.forEach(assignment => {
                if (assignedDefenders.has(assignment.to)) {
                    issues.push(`Duplicate assignment: Multiple players assigned to ${assignment.to}`);
                } else {
                    assignedDefenders.add(assignment.to);
                }
            });
            
            // Check for unblocked rush threats
            const unblockedThreats = defensive.filter(d => 
                !assignedDefenders.has(d.id) && 
                isRushThreat(d)
            );
            
            unblockedThreats.forEach(threat => {
                issues.push(`Unblocked threat: ${threat.id} at position (${threat.x}, ${threat.y})`);
            });
            
            if (issues.length > 0) {
                console.warn('⚠️ Assignment validation issues:', issues);
            }
            
            return issues;
        }

        // Check if defender is a rush threat
        function isRushThreat(defender) {
            // D-line and blitzing LBs are rush threats
            const isDLine = ['DE', 'DT', 'NG'].includes(defender.label);
            const isBlitzingLB = (defender.label === 'LB' || defender.id === 'HYB') && defender.y >= 40;
            const isOLB = defender.label === 'OLB';
            
            return isDLine || isBlitzingLB || isOLB;
        }

        // Consistent blitz detection function
        function isDefenderBlitzing(defender) {
            if (!defender) return false;
            
            // Original position for LBs is around y:25, blitzing moves them to y:40+
            const normalLBDepth = 25;
            const blitzDepth = 40;
            
            return defender.y > normalLBDepth && defender.y >= blitzDepth;
        }

        // 4-3 Defense specific assignments
        function get43Assignments(offensive, defensive, playSide, assignments, targetGap) {
            console.log('🏈 Using 4-3 specific blocking rules'); // Debug
            
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Find specific 4-3 defenders
            const de1 = defensive.find(d => d.id === 'DE1');
            const dt1 = defensive.find(d => d.id === 'DT1');
            const dt2 = defensive.find(d => d.id === 'DT2');
            const de2 = defensive.find(d => d.id === 'DE2');
            const mlb = defensive.find(d => d.id === 'MLB');
            const wlb = defensive.find(d => d.id === 'WLB');
            const slb = defensive.find(d => d.id === 'SLB');
            
            // Use consistent blitz detection
            const mlbBlitzing = isDefenderBlitzing(mlb);
            const wlbBlitzing = isDefenderBlitzing(wlb);
            const slbBlitzing = isDefenderBlitzing(slb);
            
            console.log(`🏃 4-3 Run blocking for ${playSide} side play`); // Debug
            console.log(`🚨 Blitzing LBs: MLB:${mlbBlitzing}, WLB:${wlbBlitzing}, SLB:${slbBlitzing}`); // Debug
            
            // CENTER: Check if anyone is over him first, then help with MLB
            let centerAssigned = false;
            
            if (playSide === 'left') {
                // LEFT SIDE RUNS: Prioritize left side gap where ball is going
                
                // LEFT GUARD: Check if DT1 is over him first (ON rule)
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= DISTANCE_THRESHOLDS.OVER_PLAYER;
                
                if (dt1OverLG) {
                    // DT1 over LG - block him first (ON rule)
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LG blocks DT1 (ON rule - over him)`);
                    
                    // LEFT TACKLE: Block DE1 (normal assignment)
                    if (leftTackle && de1) {
                        assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                        console.log(`✅ PLAYSIDE LT blocks DE1`);
                    }
                } else if (wlbBlitzing || (wlb && leftGuard)) {
                    // WLB blitzing OR no one over LG - get WLB (gap priority for ball direction)
                    const blockType = wlbBlitzing ? 'gap' : 'linebacker';
                    assignments.push({ from: 'LG', to: wlb.id, type: blockType });
                    console.log(`✅ PLAYSIDE LG gets WLB (${wlbBlitzing ? 'BLITZING' : 'no one over LG'}) - ball direction gap priority`);
                    
                    // Center gets DT1 (if LG has WLB), LT gets DE1
                    if (center && dt1) {
                        assignments.push({ from: 'C', to: dt1.id, type: 'on' });
                        console.log(`✅ Center takes DT1 (LG has WLB)`);
                        centerAssigned = true;
                    }
                    if (leftTackle && de1) {
                        assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                        console.log(`✅ LT gets DE1 (LG has WLB)`);
                    }
                }
                
                // RIGHT GUARD (BACKSIDE): Check if DT2 is over him first (ON rule)
                const dt2OverRG_backside = dt2 && Math.abs(dt2.x - rightGuard.x) <= 8;
                
                if (dt2OverRG_backside) {
                    // DT2 over RG - block him first (ON rule)
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RG blocks DT2 (ON rule - over him)`);
                }
                
                // RIGHT TACKLE (BACKSIDE): Block DE2 (only if not assigned above)
                if (rightTackle && de2 && !assignments.some(a => a.from === 'RT')) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RT blocks DE2`);
                }
                
            } else {
                // RIGHT SIDE RUNS: Prioritize right side gap where ball is going
                
                // RIGHT GUARD: Check if DT2 is over him first (ON rule)
                const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 8;
                
                if (dt2OverRG) {
                    // DT2 over RG - block him first (ON rule)
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RG blocks DT2 (ON rule - over him)`);
                    
                    // RIGHT TACKLE: Block DE2 (normal assignment)
                    if (rightTackle && de2) {
                        assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                        console.log(`✅ PLAYSIDE RT blocks DE2`);
                    }
                } else if (slbBlitzing || (slb && rightGuard)) {
                    // SLB blitzing OR no one over RG - get SLB (gap priority for ball direction)
                    const blockType = slbBlitzing ? 'gap' : 'linebacker';
                    assignments.push({ from: 'RG', to: slb.id, type: blockType });
                    console.log(`✅ PLAYSIDE RG gets SLB (${slbBlitzing ? 'BLITZING' : 'no one over RG'}) - ball direction gap priority`);
                    
                    // Center gets DT2 (if RG has SLB), RT gets DE2
                    if (center && dt2) {
                        assignments.push({ from: 'C', to: dt2.id, type: 'on' });
                        console.log(`✅ Center takes DT2 (RG has SLB)`);
                        centerAssigned = true;
                    }
                    if (rightTackle && de2) {
                        assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                        console.log(`✅ RT gets DE2 (RG has SLB)`);
                    }
                }
                
                // LEFT GUARD (BACKSIDE): Check if DT1 is over him first (ON rule)
                const dt1OverLG_backside = dt1 && Math.abs(dt1.x - leftGuard.x) <= 8;
                
                if (dt1OverLG_backside) {
                    // DT1 over LG - block him first (ON rule)
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LG blocks DT1 (ON rule - over him)`);
                }
                
                // LEFT TACKLE (BACKSIDE): Block DE1 (only if not assigned above)
                if (leftTackle && de1 && !assignments.some(a => a.from === 'LT')) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LT blocks DE1`);
                }
            }
            
            // CENTER: If not assigned above, check for MLB (if no one over center)
            if (!centerAssigned && center && mlb) {
                // Check if anyone is over center (defensive linemen in front of center)
                const defenderOverCenter = defensive.find(d => 
                    Math.abs(d.x - center.x) <= 8 && d.y >= 35 && d.y <= 45 && (d.label === 'DT' || d.label === 'NG')
                );
                
                console.log(`🔍 Center assignment check: centerAssigned=${centerAssigned}, defenderOverCenter=${defenderOverCenter ? defenderOverCenter.id : 'none'}`); // Debug
                
                if (!defenderOverCenter) {
                    // No one over center - he gets MLB
                    const blockType = mlbBlitzing ? 'gap' : 'linebacker';
                    assignments.push({ from: 'C', to: mlb.id, type: blockType });
                    console.log(`✅ Center gets MLB (${mlbBlitzing ? 'BLITZING' : 'no one over him'})`);
                } else {
                    console.log(`⚠️ Center can't get MLB - ${defenderOverCenter.id} is over him`); // Debug
                }
            } else {
                console.log(`⚠️ Center assignment skipped: centerAssigned=${centerAssigned}, center=${!!center}, mlb=${!!mlb}`); // Debug
            }
            
            // TIGHT END: Help with outside linebackers
            if (leftTE) {
                const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                if (teTarget) {
                    assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ LTE helps with ${teTarget.id}`);
                }
            }
            
            if (rightTE) {
                const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                if (teTarget) {
                    assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ RTE helps with ${teTarget.id}`);
                }
            }
            
            // FULLBACK - lead block unblocked linebackers in the gap
            const fullback = offensive.find(p => p.id === 'FB');
            if (fullback) {
                const fbTarget = findFullbackTarget(fullback, defensive, playSide, assignments, targetGap);
                if (fbTarget) {
                    assignments.push({ from: 'FB', to: fbTarget.id, type: 'linebacker' });
                    console.log(`✅ FB lead blocks ${fbTarget.id} in 4-3 formation`);
                }
            }
            
            console.log(`🎯 4-3 assignments complete:`, assignments.map(a => `${a.from}→${a.to}(${a.type})`));
            
            // Validate assignments
            validateAssignments(assignments, defensive);
            
            return assignments;
        }
        
        // 3-4 Defense specific assignments (THIS WEEK'S FOCUS!)
        function get34Assignments(offensive, defensive, playSide, assignments, targetGap) {
            console.log('🏈 Using 3-4 specific blocking rules for THIS WEEK!'); // Debug
            
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Find specific 3-4 defenders
            const de1 = defensive.find(d => d.id === 'DE1');
            const ng = defensive.find(d => d.id === 'NG');
            const de2 = defensive.find(d => d.id === 'DE2');
            const olb1 = defensive.find(d => d.id === 'OLB1');
            const ilb1 = defensive.find(d => d.id === 'ILB1');
            const ilb2 = defensive.find(d => d.id === 'ILB2');
            const olb2 = defensive.find(d => d.id === 'OLB2');
            
            // 3-4 RULES FOR THIS WEEK:
            // 1. GOLD PRINCIPLE: Gap → On → Linebacker → Down (priority order)
            // 2. CENTER: ALWAYS takes Nose Guard (inside gap closest to QB)
            // 3. GUARDS: Check for blitzing ILBs first, then help with DEs
            // 4. TACKLES: OLBs are edge rushers - set and anchor
            // 5. PLAYSIDE: Create movement, BACKSIDE: Cut off pursuit
            

            
            // 2. CENTER: ALWAYS takes Nose Guard (inside gap closest to QB)
            if (center && ng) {
                assignments.push({ from: 'C', to: ng.id, type: 'on' });
                console.log(`✅ Center ALWAYS blocks NG (closest to QB)`);
            }
            
            // 3. PLAYSIDE/BACKSIDE RUN BLOCKING: Prioritize inside gap where ball is going
            console.log(`🏃 3-4 Run blocking for ${playSide} side play`); // Debug
            
            // Use consistent blitz detection
            const ilb1Blitzing = isDefenderBlitzing(ilb1);
            const ilb2Blitzing = isDefenderBlitzing(ilb2);
            
            // Check if HYB is blitzing
            const hybridDefender = defensive.find(d => d.id === 'HYB');
            const hybBlitzing = isDefenderBlitzing(hybridDefender);
            
            // Determine which side HYB is on (if present)
            const hybOnLeft = hybridDefender && hybridDefender.x < 50;
            const hybOnRight = hybridDefender && hybridDefender.x >= 50;
            
            if (playSide === 'left') {
                // LEFT SIDE RUNS (1,3,5,7 gaps): Prioritize left side 
                
                // LEFT GUARD: Priority - ILB1 (if no DE1 over him), otherwise DE1
                if (ilb1Blitzing || (hybBlitzing && hybOnLeft)) {
                    // Handle blitzing linebacker
                    if (ilb1Blitzing) {
                        const blockType = getBlockType(ilb1, leftGuard);
                        assignments.push({ from: 'LG', to: ilb1.id, type: blockType });
                        console.log(`🚨 PLAYSIDE LG picks up blitzing ILB1`);
                    } else if (hybBlitzing && hybOnLeft) {
                        const blockType = getBlockType(hybridDefender, leftGuard);
                        assignments.push({ from: 'LG', to: hybridDefender.id, type: blockType });
                        console.log(`🚨 PLAYSIDE LG picks up blitzing HYB`);
                    }
                    
                    // LT slides to DE1
                    if (leftTackle && de1) {
                        assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                        console.log(`🚨 PLAYSIDE LT slides to DE1`);
                    }
                } else {
                                    // Check if DE1 is over LG or if LG should help with ILB1
                const de1OverLG = de1 && Math.abs(de1.x - leftGuard.x) <= DISTANCE_THRESHOLDS.OVER_PLAYER;
                    
                    if (de1OverLG) {
                        // DE1 over LG - block him first (ON rule)
                        assignments.push({ from: 'LG', to: de1.id, type: 'on' });
                        console.log(`✅ PLAYSIDE LG blocks DE1 (on rule - over him)`);
                    } else if (ilb1) {
                        // No DE over LG - help with playside LB
                        assignments.push({ from: 'LG', to: ilb1.id, type: 'linebacker' });
                        console.log(`✅ PLAYSIDE LG helps with ILB1 (no one over him)`);
                        
                        // LT slides to DE1 (since LG is helping with LB)
                        if (leftTackle && de1) {
                            assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                            console.log(`✅ PLAYSIDE LT slides to DE1 (LG helping with LB)`);
                        }
                    } else {
                        // LG takes DE1, LT blocks OLB1
                        if (leftGuard && de1) {
                            assignments.push({ from: 'LG', to: de1.id, type: 'on' });
                            console.log(`✅ PLAYSIDE LG blocks DE1 (fallback)`);
                        }
                        if (leftTackle && olb1) {
                            assignments.push({ from: 'LT', to: olb1.id, type: 'on' });
                            console.log(`✅ PLAYSIDE LT blocks OLB1`);
                        }
                    }
                }
                
                // RIGHT GUARD (BACKSIDE): Block DE2, help if needed
                if (ilb2Blitzing || (hybBlitzing && hybOnRight)) {
                    // Handle blitzing linebacker on backside
                    if (ilb2Blitzing) {
                        const blockType = getBlockType(ilb2, rightGuard);
                        assignments.push({ from: 'RG', to: ilb2.id, type: blockType });
                        console.log(`🚨 BACKSIDE RG picks up blitzing ILB2`);
                    } else if (hybBlitzing && hybOnRight) {
                        const blockType = getBlockType(hybridDefender, rightGuard);
                        assignments.push({ from: 'RG', to: hybridDefender.id, type: blockType });
                        console.log(`🚨 BACKSIDE RG picks up blitzing HYB`);
                    }
                    
                    // RT slides to DE2
                    if (rightTackle && de2) {
                        assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                        console.log(`🚨 BACKSIDE RT slides to DE2`);
                    }
                } else {
                                    // Check if DE2 is over RG or if RG should help with ILB2
                const de2OverRG_backside = de2 && Math.abs(de2.x - rightGuard.x) <= DISTANCE_THRESHOLDS.OVER_PLAYER;
                    
                    if (de2OverRG_backside) {
                        // DE2 over RG - block him first (ON rule)
                        assignments.push({ from: 'RG', to: de2.id, type: 'on' });
                        console.log(`✅ BACKSIDE RG blocks DE2 (on rule - over him)`);
                        
                        if (rightTackle && olb2) {
                            assignments.push({ from: 'RT', to: olb2.id, type: 'on' });
                            console.log(`✅ BACKSIDE RT blocks OLB2`);
                        }
                    } else if (ilb2) {
                        // No DE over RG - help with backside LB
                        assignments.push({ from: 'RG', to: ilb2.id, type: 'linebacker' });
                        console.log(`✅ BACKSIDE RG helps with ILB2 (no one over him)`);
                        
                        // RT slides to DE2 (since RG is helping with LB)
                        if (rightTackle && de2) {
                            assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                            console.log(`✅ BACKSIDE RT slides to DE2 (RG helping with LB)`);
                        }
                    } else {
                        // Normal assignments
                        if (rightGuard && de2) {
                            assignments.push({ from: 'RG', to: de2.id, type: 'on' });
                            console.log(`✅ BACKSIDE RG blocks DE2 (fallback)`);
                        }
                        
                        if (rightTackle && olb2) {
                            assignments.push({ from: 'RT', to: olb2.id, type: 'on' });
                            console.log(`✅ BACKSIDE RT blocks OLB2`);
                        }
                    }
                }
                
            } else {
                // RIGHT SIDE RUNS (2,4,6 gaps): Prioritize right side
                
                // RIGHT GUARD: Priority - ILB2 (if no DE2 over him), otherwise DE2
                if (ilb2Blitzing || (hybBlitzing && hybOnRight)) {
                    // Handle blitzing linebacker
                    if (ilb2Blitzing) {
                        const blockType = getBlockType(ilb2, rightGuard);
                        assignments.push({ from: 'RG', to: ilb2.id, type: blockType });
                        console.log(`🚨 PLAYSIDE RG picks up blitzing ILB2`);
                    } else if (hybBlitzing && hybOnRight) {
                        const blockType = getBlockType(hybridDefender, rightGuard);
                        assignments.push({ from: 'RG', to: hybridDefender.id, type: blockType });
                        console.log(`🚨 PLAYSIDE RG picks up blitzing HYB`);
                    }
                    
                    // RT slides to DE2
                    if (rightTackle && de2) {
                        assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                        console.log(`🚨 PLAYSIDE RT slides to DE2`);
                    }
                } else {
                    // Check if DE2 is over RG or if RG should help with ILB2
                    const de2OverRG = de2 && Math.abs(de2.x - rightGuard.x) <= 5;
                    
                    if (de2OverRG) {
                        // DE2 over RG - block him first (ON rule)
                        assignments.push({ from: 'RG', to: de2.id, type: 'on' });
                        console.log(`✅ PLAYSIDE RG blocks DE2 (on rule - over him)`);
                    } else if (ilb2) {
                        // No DE over RG - help with playside LB
                        assignments.push({ from: 'RG', to: ilb2.id, type: 'linebacker' });
                        console.log(`✅ PLAYSIDE RG helps with ILB2 (no one over him)`);
                        
                        // RT slides to DE2 (since RG is helping with LB)
                        if (rightTackle && de2) {
                            assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                            console.log(`✅ PLAYSIDE RT slides to DE2 (RG helping with LB)`);
                        }
                    } else {
                        // RG takes DE2, RT blocks OLB2
                        if (rightGuard && de2) {
                            assignments.push({ from: 'RG', to: de2.id, type: 'on' });
                            console.log(`✅ PLAYSIDE RG blocks DE2 (fallback)`);
                        }
                        if (rightTackle && olb2) {
                            assignments.push({ from: 'RT', to: olb2.id, type: 'on' });
                            console.log(`✅ PLAYSIDE RT blocks OLB2`);
                        }
                    }
                }
                
                // LEFT GUARD (BACKSIDE): Block DE1, help if needed
                if (ilb1Blitzing || (hybBlitzing && hybOnLeft)) {
                    // Handle blitzing linebacker on backside
                    if (ilb1Blitzing) {
                        const blockType = getBlockType(ilb1, leftGuard);
                        assignments.push({ from: 'LG', to: ilb1.id, type: blockType });
                        console.log(`🚨 BACKSIDE LG picks up blitzing ILB1`);
                    } else if (hybBlitzing && hybOnLeft) {
                        const blockType = getBlockType(hybridDefender, leftGuard);
                        assignments.push({ from: 'LG', to: hybridDefender.id, type: blockType });
                        console.log(`🚨 BACKSIDE LG picks up blitzing HYB`);
                    }
                    
                    // LT slides to DE1
                    if (leftTackle && de1) {
                        assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                        console.log(`🚨 BACKSIDE LT slides to DE1`);
                    }
                } else {
                    // Check if DE1 is over LG or if LG should help with ILB1
                    const de1OverLG_backside = de1 && Math.abs(de1.x - leftGuard.x) <= 5;
                    
                    if (de1OverLG_backside) {
                        // DE1 over LG - block him first (ON rule)
                        assignments.push({ from: 'LG', to: de1.id, type: 'on' });
                        console.log(`✅ BACKSIDE LG blocks DE1 (on rule - over him)`);
                        
                        if (leftTackle && olb1) {
                            assignments.push({ from: 'LT', to: olb1.id, type: 'on' });
                            console.log(`✅ BACKSIDE LT blocks OLB1`);
                        }
                    } else if (ilb1) {
                        // No DE over LG - help with backside LB
                        assignments.push({ from: 'LG', to: ilb1.id, type: 'linebacker' });
                        console.log(`✅ BACKSIDE LG helps with ILB1 (no one over him)`);
                        
                        // LT slides to DE1 (since LG is helping with LB)
                        if (leftTackle && de1) {
                            assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                            console.log(`✅ BACKSIDE LT slides to DE1 (LG helping with LB)`);
                        }
                    } else {
                        // Normal assignments
                        if (leftGuard && de1) {
                            assignments.push({ from: 'LG', to: de1.id, type: 'on' });
                            console.log(`✅ BACKSIDE LG blocks DE1 (fallback)`);
                        }
                        
                        if (leftTackle && olb1) {
                            assignments.push({ from: 'LT', to: olb1.id, type: 'on' });
                            console.log(`✅ BACKSIDE LT blocks OLB1`);
                        }
                    }
                }
            }
            
            // 4. TIGHT END: Help with outside linebackers or Star defender
            if (leftTE) {
                const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                if (teTarget) {
                    assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ LTE helps with ${teTarget.id}`);
                }
            }
            
            if (rightTE) {
                const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                if (teTarget) {
                    assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ RTE helps with ${teTarget.id}`);
                }
            }
            

            
            // FULLBACK - lead block unblocked linebackers in the gap
            const fullback = offensive.find(p => p.id === 'FB');
            if (fullback) {
                const fbTarget = findFullbackTarget(fullback, defensive, playSide, assignments, targetGap);
                if (fbTarget) {
                    assignments.push({ from: 'FB', to: fbTarget.id, type: 'linebacker' });
                    console.log(`✅ FB lead blocks ${fbTarget.id} in 3-4 formation`);
                }
            }
            
            console.log(`🎯 3-4 assignments complete:`, assignments.map(a => `${a.from}→${a.to}(${a.type})`));
            
            // Validate assignments
            validateAssignments(assignments, defensive);
            
            return assignments;
        }
        
        // 4-4 Defense specific assignments
        function get44Assignments(offensive, defensive, playSide, assignments, targetGap) {
            console.log('🏈 Using 4-4 specific blocking rules'); // Debug
            
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Find specific 4-4 defenders
            const de1 = defensive.find(d => d.id === 'DE1');
            const dt1 = defensive.find(d => d.id === 'DT1');
            const dt2 = defensive.find(d => d.id === 'DT2');
            const de2 = defensive.find(d => d.id === 'DE2');
            const lb1 = defensive.find(d => d.id === 'LB1');
            const lb2 = defensive.find(d => d.id === 'LB2');
            const lb3 = defensive.find(d => d.id === 'LB3');
            const lb4 = defensive.find(d => d.id === 'LB4');
            
            // Check for blitzing linebackers (they move from y:25 to y:45 when blitzing)
            const lb1Blitzing = lb1 && lb1.y > 25 && lb1.y <= 45;
            const lb2Blitzing = lb2 && lb2.y > 25 && lb2.y <= 45;
            const lb3Blitzing = lb3 && lb3.y > 25 && lb3.y <= 45;
            const lb4Blitzing = lb4 && lb4.y > 25 && lb4.y <= 45;
            
            console.log(`🏃 4-4 Run blocking for ${playSide} side play`); // Debug
            console.log(`🚨 Blitzing LBs: LB1:${lb1Blitzing}, LB2:${lb2Blitzing}, LB3:${lb3Blitzing}, LB4:${lb4Blitzing}`); // Debug
            
            // CENTER: Prioritize inside gap closest to center (LB2 or LB3)
            if (center) {
                const insideLBs = [lb2, lb3].filter(lb => lb);
                let centerTarget = null;
                
                // Check for blitzing inside LBs first
                const blitzingInsideLBs = insideLBs.filter(lb => lb.y > 25 && lb.y <= 45);
                if (blitzingInsideLBs.length > 0) {
                    // Take closest blitzing inside LB
                    centerTarget = blitzingInsideLBs.sort((a, b) => 
                        Math.abs(a.x - center.x) - Math.abs(b.x - center.x)
                    )[0];
                    assignments.push({ from: 'C', to: centerTarget.id, type: 'gap' });
                    console.log(`✅ Center blocks blitzing ${centerTarget.id}`);
                } else if (insideLBs.length > 0) {
                    // Take closest inside LB
                    centerTarget = insideLBs.sort((a, b) => 
                        Math.abs(a.x - center.x) - Math.abs(b.x - center.x)
                    )[0];
                    assignments.push({ from: 'C', to: centerTarget.id, type: 'linebacker' });
                    console.log(`✅ Center blocks ${centerTarget.id} (normal)`);
                }
            }
            
            if (playSide === 'left') {
                // LEFT SIDE RUNS: Prioritize left side
                
                // LEFT GUARD: Check for DT1 over him, otherwise help with LB2
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= 5;
                
                if (dt1OverLG) {
                    // DT1 over LG - block him first (ON rule)
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LG blocks DT1 (on rule - over him)`);
                } else if (lb2Blitzing && leftGuard) {
                    // LB2 blitzing - LG picks up
                    assignments.push({ from: 'LG', to: lb2.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE LG picks up blitzing LB2`);
                } else if (lb2 && leftGuard) {
                    // Help with LB2
                    assignments.push({ from: 'LG', to: lb2.id, type: 'linebacker' });
                    console.log(`✅ PLAYSIDE LG helps with LB2`);
                }
                
                // LEFT TACKLE: Block DE1
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LT blocks DE1`);
                }
                
                // RIGHT GUARD & TACKLE (BACKSIDE)
                const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 5;
                
                if (dt2OverRG) {
                    // DT2 over RG - block him first
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RG blocks DT2 (on rule - over him)`);
                } else if (lb3Blitzing && rightGuard) {
                    // LB3 blitzing - RG picks up
                    assignments.push({ from: 'RG', to: lb3.id, type: 'gap' });
                    console.log(`🚨 BACKSIDE RG picks up blitzing LB3`);
                } else if (lb3 && rightGuard) {
                    // Help with LB3
                    assignments.push({ from: 'RG', to: lb3.id, type: 'linebacker' });
                    console.log(`✅ BACKSIDE RG helps with LB3`);
                }
                
                if (rightTackle && de2) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RT blocks DE2`);
                }
                
            } else {
                // RIGHT SIDE RUNS: Prioritize right side
                
                // RIGHT GUARD: Check for DT2 over him, otherwise help with LB3
                const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 5;
                
                if (dt2OverRG) {
                    // DT2 over RG - block him first (ON rule)
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RG blocks DT2 (on rule - over him)`);
                } else if (lb3Blitzing && rightGuard) {
                    // LB3 blitzing - RG picks up
                    assignments.push({ from: 'RG', to: lb3.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE RG picks up blitzing LB3`);
                } else if (lb3 && rightGuard) {
                    // Help with LB3
                    assignments.push({ from: 'RG', to: lb3.id, type: 'linebacker' });
                    console.log(`✅ PLAYSIDE RG helps with LB3`);
                }
                
                // RIGHT TACKLE: Block DE2
                if (rightTackle && de2) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RT blocks DE2`);
                }
                
                // LEFT GUARD & TACKLE (BACKSIDE)
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= 5;
                
                if (dt1OverLG) {
                    // DT1 over LG - block him first
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LG blocks DT1 (on rule - over him)`);
                } else if (lb2Blitzing && leftGuard) {
                    // LB2 blitzing - LG picks up
                    assignments.push({ from: 'LG', to: lb2.id, type: 'gap' });
                    console.log(`🚨 BACKSIDE LG picks up blitzing LB2`);
                } else if (lb2 && leftGuard) {
                    // Help with LB2
                    assignments.push({ from: 'LG', to: lb2.id, type: 'linebacker' });
                    console.log(`✅ BACKSIDE LG helps with LB2`);
                }
                
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LT blocks DE1`);
                }
            }
            
            // TIGHT END: Help with outside linebackers
            if (leftTE) {
                const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                if (teTarget) {
                    assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ LTE helps with ${teTarget.id}`);
                }
            }
            
            if (rightTE) {
                const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                if (teTarget) {
                    assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ RTE helps with ${teTarget.id}`);
                }
            }
            
            // FULLBACK - lead block unblocked linebackers in the gap
            const fullback = offensive.find(p => p.id === 'FB');
            if (fullback) {
                const fbTarget = findFullbackTarget(fullback, defensive, playSide, assignments, targetGap);
                if (fbTarget) {
                    assignments.push({ from: 'FB', to: fbTarget.id, type: 'linebacker' });
                    console.log(`✅ FB lead blocks ${fbTarget.id} in 4-4 formation`);
                }
            }
            
            console.log(`🎯 4-4 assignments complete:`, assignments.map(a => `${a.from}→${a.to}(${a.type})`));
            return assignments;
        }
        
        // 5-2 Defense specific assignments
        function get52Assignments(offensive, defensive, playSide, assignments, targetGap) {
            console.log('🏈 Using 5-2 specific blocking rules'); // Debug
            
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Find specific 5-2 defenders
            const de1 = defensive.find(d => d.id === 'DE1');
            const dt1 = defensive.find(d => d.id === 'DT1');
            const ng = defensive.find(d => d.id === 'NG');
            const dt2 = defensive.find(d => d.id === 'DT2');
            const de2 = defensive.find(d => d.id === 'DE2');
            const lb1 = defensive.find(d => d.id === 'LB1');
            const lb2 = defensive.find(d => d.id === 'LB2');
            
            // Check for blitzing linebackers (they move from y:25 to y:45 when blitzing)
            const lb1Blitzing = lb1 && lb1.y > 25 && lb1.y <= 45;
            const lb2Blitzing = lb2 && lb2.y > 25 && lb2.y <= 45;
            
            console.log(`🏃 5-2 Run blocking for ${playSide} side play`); // Debug
            console.log(`🚨 Blitzing LBs: LB1:${lb1Blitzing}, LB2:${lb2Blitzing}`); // Debug
            
            // CENTER: Always takes Nose Guard (over center)
            if (center && ng) {
                assignments.push({ from: 'C', to: ng.id, type: 'on' });
                console.log(`✅ Center blocks NG (on rule - over him)`);
            }
            
            if (playSide === 'left') {
                // LEFT SIDE RUNS: Prioritize left side
                
                // LEFT GUARD: Gap-specific priority rules
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= 5;
                const isInsideGapLeft = targetGap === '1' || targetGap === '3'; // Inside gaps for left side (1=A-gap, 3=B-gap)
                
                console.log(`🔍 LG Logic Check: dt1OverLG=${dt1OverLG}, lb1Blitzing=${lb1Blitzing}, isInsideGapLeft=${isInsideGapLeft}, targetGap=${targetGap}`);
                
                if (lb1Blitzing && isInsideGapLeft && dt1OverLG) {
                    // Inside gaps (1,3) with LB blitzing AND DT over guard: Guard keeps DT, Tackle gets LB
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LG keeps DT1 (inside gap ${targetGap} - ON rule priority over blitzing LB)`);
                    
                    // Left Tackle slides to pick up blitzing LB1
                    if (leftTackle) {
                        assignments.push({ from: 'LT', to: lb1.id, type: 'gap' });
                        console.log(`🚨 PLAYSIDE LT slides to blitzing LB1 (inside gap help)`);
                    }
                } else if (lb1Blitzing && !isInsideGapLeft && leftGuard) {
                    // Outside gaps (5,7): Guard takes LB, prioritize gap
                    assignments.push({ from: 'LG', to: lb1.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE LG picks up blitzing LB1 (outside gap ${targetGap} priority)`);
                } else if (dt1OverLG) {
                    // DT over guard - normal ON rule
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LG blocks DT1 (on rule - over him)`);
                } else if (lb1Blitzing && leftGuard) {
                    // LB blitzing but no DT over guard
                    assignments.push({ from: 'LG', to: lb1.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE LG picks up blitzing LB1 (no DT over him)`);
                } else if (lb1 && leftGuard) {
                    // Help with LB1
                    assignments.push({ from: 'LG', to: lb1.id, type: 'linebacker' });
                    console.log(`✅ PLAYSIDE LG helps with LB1`);
                }
                
                // LEFT TACKLE: Block DE1
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LT blocks DE1`);
                }
                
                // RIGHT GUARD (BACKSIDE): Check if LB2 is blitzing first
                if (lb2Blitzing && rightGuard) {
                    // LB2 blitzing - priority over DT2
                    assignments.push({ from: 'RG', to: lb2.id, type: 'gap' });
                    console.log(`🚨 BACKSIDE RG picks up blitzing LB2 (blitz priority over DT)`);
                } else {
                    const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 5;
                    
                    if (dt2OverRG) {
                        // DT2 over RG - block him first
                        assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                        console.log(`✅ BACKSIDE RG blocks DT2 (on rule - over him)`);
                    } else if (lb2 && rightGuard) {
                        // Help with LB2
                        assignments.push({ from: 'RG', to: lb2.id, type: 'linebacker' });
                        console.log(`✅ BACKSIDE RG helps with LB2`);
                    }
                }
                
                if (rightTackle && de2) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RT blocks DE2`);
                }
                
            } else {
                // RIGHT SIDE RUNS: Prioritize right side
                
                // RIGHT GUARD: Gap-specific priority rules
                const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 5;
                const isInsideGap = targetGap === '2' || targetGap === '4'; // Inside gaps for right side (2=A-gap, 4=B-gap)
                
                console.log(`🔍 RG Logic Check: dt2OverRG=${dt2OverRG}, lb2Blitzing=${lb2Blitzing}, isInsideGap=${isInsideGap}, targetGap=${targetGap}`);
                
                if (lb2Blitzing && isInsideGap && dt2OverRG) {
                    // Inside gaps (1,2) with LB blitzing AND DT over guard: Guard keeps DT, Tackle gets LB
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RG keeps DT2 (inside gap ${targetGap} - ON rule priority over blitzing LB)`);
                    
                    // Right Tackle slides to pick up blitzing LB2
                    if (rightTackle) {
                        assignments.push({ from: 'RT', to: lb2.id, type: 'gap' });
                        console.log(`🚨 PLAYSIDE RT slides to blitzing LB2 (inside gap help)`);
                    }
                } else if (lb2Blitzing && !isInsideGap && rightGuard) {
                    // Outside gaps (4,6): Guard takes LB, prioritize gap
                    assignments.push({ from: 'RG', to: lb2.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE RG picks up blitzing LB2 (outside gap ${targetGap} priority)`);
                } else if (dt2OverRG) {
                    // DT over guard - normal ON rule
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RG blocks DT2 (on rule - over him)`);
                } else if (lb2Blitzing && rightGuard) {
                    // LB blitzing but no DT over guard
                    assignments.push({ from: 'RG', to: lb2.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE RG picks up blitzing LB2 (no DT over him)`);
                } else if (lb2 && rightGuard) {
                    // Help with LB2
                    assignments.push({ from: 'RG', to: lb2.id, type: 'linebacker' });
                    console.log(`✅ PLAYSIDE RG helps with LB2`);
                }
                
                // RIGHT TACKLE: Block DE2 (if not already assigned to LB)
                if (rightTackle && de2) {
                    // Check if RT is already assigned to a blitzing LB
                    const rtAlreadyAssigned = assignments.some(a => a.from === 'RT');
                    if (!rtAlreadyAssigned) {
                        assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                        console.log(`✅ PLAYSIDE RT blocks DE2`);
                    }
                }
                
                // LEFT GUARD & TACKLE (BACKSIDE)
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= 5;
                
                if (dt1OverLG) {
                    // DT1 over LG - block him first
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LG blocks DT1 (on rule - over him)`);
                } else if (lb1Blitzing && leftGuard) {
                    // LB1 blitzing - LG picks up
                    assignments.push({ from: 'LG', to: lb1.id, type: 'gap' });
                    console.log(`🚨 BACKSIDE LG picks up blitzing LB1`);
                } else if (lb1 && leftGuard) {
                    // Help with LB1
                    assignments.push({ from: 'LG', to: lb1.id, type: 'linebacker' });
                    console.log(`✅ BACKSIDE LG helps with LB1`);
                }
                
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LT blocks DE1`);
                }
            }
            
            // TIGHT END: Help with outside linebackers
            if (leftTE) {
                const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                if (teTarget) {
                    assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ LTE helps with ${teTarget.id}`);
                }
            }
            
            if (rightTE) {
                const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                if (teTarget) {
                    assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ RTE helps with ${teTarget.id}`);
                }
            }
            
            console.log(`🎯 5-2 assignments complete:`, assignments.map(a => `${a.from}→${a.to}(${a.type})`));
            return assignments;
        }
        
        // 5-3 Defense specific assignments
        function get53Assignments(offensive, defensive, playSide, assignments) {
            console.log('🏈 Using 5-3 specific blocking rules'); // Debug
            
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Find specific 5-3 defenders
            const de1 = defensive.find(d => d.id === 'DE1');
            const dt1 = defensive.find(d => d.id === 'DT1');
            const ng = defensive.find(d => d.id === 'NG');
            const dt2 = defensive.find(d => d.id === 'DT2');
            const de2 = defensive.find(d => d.id === 'DE2');
            const lb1 = defensive.find(d => d.id === 'LB1');
            const lb2 = defensive.find(d => d.id === 'LB2');
            const lb3 = defensive.find(d => d.id === 'LB3');
            
            // Check for blitzing linebackers (they move from y:25 to y:45 when blitzing)
            const lb1Blitzing = lb1 && lb1.y > 25 && lb1.y <= 45;
            const lb2Blitzing = lb2 && lb2.y > 25 && lb2.y <= 45;
            const lb3Blitzing = lb3 && lb3.y > 25 && lb3.y <= 45;
            
            console.log(`🏃 5-3 Run blocking for ${playSide} side play`); // Debug
            console.log(`🚨 Blitzing LBs: LB1:${lb1Blitzing}, LB2:${lb2Blitzing}, LB3:${lb3Blitzing}`); // Debug
            
            // CENTER: Always takes Nose Guard (over center)
            if (center && ng) {
                assignments.push({ from: 'C', to: ng.id, type: 'on' });
                console.log(`✅ Center blocks NG (on rule - over him)`);
            }
            
            if (playSide === 'left') {
                // LEFT SIDE RUNS: Prioritize left side
                
                // LEFT GUARD: Check for DT1 over him, otherwise help with LB1
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= 5;
                
                if (dt1OverLG) {
                    // DT1 over LG - block him first (ON rule)
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LG blocks DT1 (on rule - over him)`);
                } else if (lb1Blitzing && leftGuard) {
                    // LB1 blitzing - LG picks up
                    assignments.push({ from: 'LG', to: lb1.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE LG picks up blitzing LB1`);
                } else if (lb1 && leftGuard) {
                    // Help with LB1
                    assignments.push({ from: 'LG', to: lb1.id, type: 'linebacker' });
                    console.log(`✅ PLAYSIDE LG helps with LB1`);
                }
                
                // LEFT TACKLE: Block DE1
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ PLAYSIDE LT blocks DE1`);
                }
                
                // RIGHT GUARD & TACKLE (BACKSIDE)
                const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 5;
                
                if (dt2OverRG) {
                    // DT2 over RG - block him first
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RG blocks DT2 (on rule - over him)`);
                } else if (lb3Blitzing && rightGuard) {
                    // LB3 blitzing - RG picks up
                    assignments.push({ from: 'RG', to: lb3.id, type: 'gap' });
                    console.log(`🚨 BACKSIDE RG picks up blitzing LB3`);
                } else if (lb3 && rightGuard) {
                    // Help with LB3
                    assignments.push({ from: 'RG', to: lb3.id, type: 'linebacker' });
                    console.log(`✅ BACKSIDE RG helps with LB3`);
                }
                
                if (rightTackle && de2) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log(`✅ BACKSIDE RT blocks DE2`);
                }
                
            } else {
                // RIGHT SIDE RUNS: Prioritize right side
                
                // RIGHT GUARD: Check for DT2 over him, otherwise help with LB3
                const dt2OverRG = dt2 && Math.abs(dt2.x - rightGuard.x) <= 5;
                
                if (dt2OverRG) {
                    // DT2 over RG - block him first (ON rule)
                    assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RG blocks DT2 (on rule - over him)`);
                } else if (lb3Blitzing && rightGuard) {
                    // LB3 blitzing - RG picks up
                    assignments.push({ from: 'RG', to: lb3.id, type: 'gap' });
                    console.log(`🚨 PLAYSIDE RG picks up blitzing LB3`);
                } else if (lb3 && rightGuard) {
                    // Help with LB3
                    assignments.push({ from: 'RG', to: lb3.id, type: 'linebacker' });
                    console.log(`✅ PLAYSIDE RG helps with LB3`);
                }
                
                // RIGHT TACKLE: Block DE2
                if (rightTackle && de2) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log(`✅ PLAYSIDE RT blocks DE2`);
                }
                
                // LEFT GUARD & TACKLE (BACKSIDE)
                const dt1OverLG = dt1 && Math.abs(dt1.x - leftGuard.x) <= 5;
                
                if (dt1OverLG) {
                    // DT1 over LG - block him first
                    assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LG blocks DT1 (on rule - over him)`);
                } else if (lb1Blitzing && leftGuard) {
                    // LB1 blitzing - LG picks up
                    assignments.push({ from: 'LG', to: lb1.id, type: 'gap' });
                    console.log(`🚨 BACKSIDE LG picks up blitzing LB1`);
                } else if (lb1 && leftGuard) {
                    // Help with LB1
                    assignments.push({ from: 'LG', to: lb1.id, type: 'linebacker' });
                    console.log(`✅ BACKSIDE LG helps with LB1`);
                }
                
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log(`✅ BACKSIDE LT blocks DE1`);
                }
            }
            
            // TIGHT END: Help with outside linebackers
            if (leftTE) {
                const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                if (teTarget) {
                    assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ LTE helps with ${teTarget.id}`);
                }
            }
            
            if (rightTE) {
                const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                if (teTarget) {
                    assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ RTE helps with ${teTarget.id}`);
                }
            }
            
            console.log(`🎯 5-3 assignments complete:`, assignments.map(a => `${a.from}→${a.to}(${a.type})`));
            return assignments;
        }
        
        // 6-2 Defense specific assignments
        function get62Assignments(offensive, defensive, playSide, assignments) {
            console.log('🏈 Using 6-2 specific blocking rules'); // Debug
            
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // Find all 6-2 defenders (6 down linemen, 2 linebackers)
            const allDL = defensive.filter(d => d.label === 'DT' || d.label === 'DE' || d.label === 'NG');
            const allLBs = defensive.filter(d => d.label === 'LB');
            
            // Sort DL by x position to identify who's over whom
            const sortedDL = allDL.sort((a, b) => a.x - b.x);
            
            // Check for blitzing linebackers
            const blitzingLBs = allLBs.filter(lb => lb.y > 25 && lb.y <= 45);
            
            console.log(`🏃 6-2 Run blocking for ${playSide} side play`); // Debug
            console.log(`🚨 Blitzing LBs:`, blitzingLBs.map(lb => lb.id)); // Debug
            
            // CENTER: Find closest DL over center or help with blitzing LBs
            if (center) {
                const centerDL = sortedDL.find(dl => Math.abs(dl.x - center.x) <= 8);
                if (centerDL) {
                    assignments.push({ from: 'C', to: centerDL.id, type: 'on' });
                    console.log(`✅ Center blocks ${centerDL.id} (on rule - over him)`);
                } else if (blitzingLBs.length > 0) {
                    // Help with closest blitzing LB
                    const closestBlitzLB = blitzingLBs.sort((a, b) => 
                        Math.abs(a.x - center.x) - Math.abs(b.x - center.x)
                    )[0];
                    assignments.push({ from: 'C', to: closestBlitzLB.id, type: 'gap' });
                    console.log(`✅ Center picks up blitzing ${closestBlitzLB.id}`);
                }
            }
            
            // LEFT GUARD: Find DL over him or help
            if (leftGuard) {
                const lgDL = sortedDL.find(dl => Math.abs(dl.x - leftGuard.x) <= 8);
                if (lgDL) {
                    assignments.push({ from: 'LG', to: lgDL.id, type: 'on' });
                    console.log(`✅ LG blocks ${lgDL.id} (on rule - over him)`);
                } else {
                    // Help with closest blitzing LB or inside help
                    const leftBlitzLBs = blitzingLBs.filter(lb => lb.x <= 50);
                    if (leftBlitzLBs.length > 0) {
                        const closestLeftBlitz = leftBlitzLBs.sort((a, b) => 
                            Math.abs(a.x - leftGuard.x) - Math.abs(b.x - leftGuard.x)
                        )[0];
                        assignments.push({ from: 'LG', to: closestLeftBlitz.id, type: 'gap' });
                        console.log(`🚨 LG picks up blitzing ${closestLeftBlitz.id}`);
                    }
                }
            }
            
            // RIGHT GUARD: Find DL over him or help
            if (rightGuard) {
                const rgDL = sortedDL.find(dl => Math.abs(dl.x - rightGuard.x) <= 8);
                if (rgDL) {
                    assignments.push({ from: 'RG', to: rgDL.id, type: 'on' });
                    console.log(`✅ RG blocks ${rgDL.id} (on rule - over him)`);
                } else {
                    // Help with closest blitzing LB or inside help
                    const rightBlitzLBs = blitzingLBs.filter(lb => lb.x >= 50);
                    if (rightBlitzLBs.length > 0) {
                        const closestRightBlitz = rightBlitzLBs.sort((a, b) => 
                            Math.abs(a.x - rightGuard.x) - Math.abs(b.x - rightGuard.x)
                        )[0];
                        assignments.push({ from: 'RG', to: closestRightBlitz.id, type: 'gap' });
                        console.log(`🚨 RG picks up blitzing ${closestRightBlitz.id}`);
                    }
                }
            }
            
            // LEFT TACKLE: Find leftmost unassigned DL
            if (leftTackle) {
                const ltDL = sortedDL.find(dl => 
                    dl.x <= 40 && !assignments.some(a => a.to === dl.id)
                );
                if (ltDL) {
                    assignments.push({ from: 'LT', to: ltDL.id, type: 'on' });
                    console.log(`✅ LT blocks ${ltDL.id}`);
                }
            }
            
            // RIGHT TACKLE: Find rightmost unassigned DL
            if (rightTackle) {
                const rtDL = sortedDL.reverse().find(dl => 
                    dl.x >= 60 && !assignments.some(a => a.to === dl.id)
                );
                if (rtDL) {
                    assignments.push({ from: 'RT', to: rtDL.id, type: 'on' });
                    console.log(`✅ RT blocks ${rtDL.id}`);
                }
            }
            
            // TIGHT END: Help with remaining threats
            if (leftTE) {
                const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                if (teTarget) {
                    assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ LTE helps with ${teTarget.id}`);
                }
            }
            
            if (rightTE) {
                const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                if (teTarget) {
                    assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                    console.log(`✅ RTE helps with ${teTarget.id}`);
                }
            }
            
            console.log(`🎯 6-2 assignments complete:`, assignments.map(a => `${a.from}→${a.to}(${a.type})`));
            return assignments;
        }
        
        // Generic assignment logic (the original logic)
        function getGenericAssignments(offensive, defensive, playSide, assignments) {
            // Get offensive players by position
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const leftTE = offensive.find(p => p.id === 'LTE');
            const rightTE = offensive.find(p => p.id === 'RTE');
            const fullback = offensive.find(p => p.id === 'FB');
            
            const isLeftPlay = playSide === 'left';
            
            if (isLeftPlay) {
                // LEFT SIDE PLAY - Playside: LT, LG, C; Backside: RG, RT
                
                // PLAYSIDE assignments (LT, LG, C)
                if (leftTackle) {
                    const ltTarget = findPlaySideTarget(leftTackle, defensive, 'left');
                    if (ltTarget) assignments.push({ from: 'LT', to: ltTarget.id, type: 'on' });
                }
                
                if (leftGuard) {
                    const lgTarget = findPlaySideTarget(leftGuard, defensive, 'left');
                    if (lgTarget) assignments.push({ from: 'LG', to: lgTarget.id, type: getBlockType(lgTarget, leftGuard, 'left') });
                }
                
                if (center) {
                    const cTarget = findCenterTarget(center, defensive, 'left');
                    if (cTarget) assignments.push({ from: 'C', to: cTarget.id, type: getBlockType(cTarget, center, 'left') });
                }
                
                // BACKSIDE assignments (RG, RT) - CUT OFF PURSUIT
                if (rightGuard) {
                    const rgTarget = findBackSideTarget(rightGuard, defensive, 'right');
                    if (rgTarget) assignments.push({ from: 'RG', to: rgTarget.id, type: 'down' });
                }
                
                if (rightTackle) {
                    const rtTarget = findBackSideTarget(rightTackle, defensive, 'right');
                    if (rtTarget) assignments.push({ from: 'RT', to: rtTarget.id, type: 'down' });
                }
                
                // LEFT TE - help playside (avoid doubling with LT)
                if (leftTE) {
                    const teTarget = findTightEndTarget(leftTE, defensive, 'left', assignments);
                    if (teTarget) assignments.push({ from: 'LTE', to: teTarget.id, type: 'on' });
                }
                
                // FULLBACK - lead block unblocked linebackers in the gap
                if (fullback) {
                    const fbTarget = findFullbackTarget(fullback, defensive, 'left', assignments, targetGap);
                    if (fbTarget) {
                        assignments.push({ from: 'FB', to: fbTarget.id, type: 'linebacker' });
                        console.log(`✅ FB lead blocks ${fbTarget.id} on left side play`);
                    }
                }
                
            } else {
                // RIGHT SIDE PLAY - Playside: RT, RG, C; Backside: LG, LT
                
                // PLAYSIDE assignments (RT, RG, C)
                if (rightTackle) {
                    const rtTarget = findPlaySideTarget(rightTackle, defensive, 'right');
                    if (rtTarget) assignments.push({ from: 'RT', to: rtTarget.id, type: 'on' });
                }
                
                if (rightGuard) {
                    const rgTarget = findPlaySideTarget(rightGuard, defensive, 'right');
                    if (rgTarget) assignments.push({ from: 'RG', to: rgTarget.id, type: getBlockType(rgTarget, rightGuard, 'right') });
                }
                
                if (center) {
                    const cTarget = findCenterTarget(center, defensive, 'right');
                    if (cTarget) assignments.push({ from: 'C', to: cTarget.id, type: getBlockType(cTarget, center, 'right') });
                }
                
                // BACKSIDE assignments (LG, LT) - CUT OFF PURSUIT
                if (leftGuard) {
                    const lgTarget = findBackSideTarget(leftGuard, defensive, 'left');
                    if (lgTarget) assignments.push({ from: 'LG', to: lgTarget.id, type: 'down' });
                }
                
                if (leftTackle) {
                    const ltTarget = findBackSideTarget(leftTackle, defensive, 'left');
                    if (ltTarget) assignments.push({ from: 'LT', to: ltTarget.id, type: 'down' });
                }
                
                // RIGHT TE - help playside (avoid doubling with RT)
                if (rightTE) {
                    const teTarget = findTightEndTarget(rightTE, defensive, 'right', assignments);
                    if (teTarget) assignments.push({ from: 'RTE', to: teTarget.id, type: 'on' });
                }
                
                // FULLBACK - lead block unblocked linebackers in the gap
                if (fullback) {
                    const fbTarget = findFullbackTarget(fullback, defensive, 'right', assignments, targetGap);
                    if (fbTarget) {
                        assignments.push({ from: 'FB', to: fbTarget.id, type: 'linebacker' });
                        console.log(`✅ FB lead blocks ${fbTarget.id} on right side play`);
                    }
                }
            }
            
            return assignments;
        }

        // Find playside target using GOLD principle: Gap → On → Linebacker → (Closest to ball)
        function findPlaySideTarget(offPlayer, defensive, side, targetGap = null) {
            console.log(`🎯 ${offPlayer.id} (x:${offPlayer.x}) looking for target on ${side} side using GOLD...`); // Debug
            
            // GOLD RULE 1: GAP - Check for gap threats (blitzing LBs in your gap)
            const gapThreats = defensive.filter(d => {
                const isInGap = Math.abs(d.x - offPlayer.x) <= DISTANCE_THRESHOLDS.BLITZ_DETECTION;
                const isBlitzing = isDefenderBlitzing(d);
                return isInGap && isBlitzing;
            });
            
            if (gapThreats.length > 0) {
                const closestGapThreat = gapThreats[0];
                console.log(`✅ GOLD-GAP: ${offPlayer.id} takes gap threat: ${closestGapThreat.id}`); // Debug
                return closestGapThreat;
            }
            
            // GOLD RULE 2: ON - Check for defender over you (head-up or shaded)
            const manOver = defensive.find(d => 
                Math.abs(d.x - offPlayer.x) <= DISTANCE_THRESHOLDS.OVER_PLAYER && 
                d.y < offPlayer.y && 
                (d.label === 'DT' || d.label === 'DE' || d.label === 'NG')
            );
            if (manOver) {
                console.log(`✅ GOLD-ON: ${offPlayer.id} takes man over: ${manOver.id}`); // Debug
                return manOver;
            }
            
            // GOLD RULE 3: LINEBACKER - Check for linebackers first
            const linebackerTarget = defensive.find(d => 
                (d.label === 'LB' || d.id === 'HYB') && 
                Math.abs(d.x - offPlayer.x) <= DISTANCE_THRESHOLDS.PLAYSIDE_HELP
            );
            
            if (linebackerTarget) {
                console.log(`✅ GOLD-LINEBACKER: ${offPlayer.id} helps with: ${linebackerTarget.id}`); // Debug
                return linebackerTarget;
            }
            
            // GOLD RULE 4: Prioritize defenders closest to the gap/ball direction
            const availableDefenders = defensive.filter(d => 
                (d.label === 'DT' || d.label === 'DE' || d.label === 'NG') &&
                Math.abs(d.x - offPlayer.x) <= 25 // Reasonable blocking range
            );
            
            if (availableDefenders.length > 0) {
                // Sort by closest to offensive player (closest to gap/ball)
                availableDefenders.sort((a, b) => 
                    Math.abs(a.x - offPlayer.x) - Math.abs(b.x - offPlayer.x)
                );
                
                const closestDefender = availableDefenders[0];
                console.log(`✅ GOLD-CLOSEST: ${offPlayer.id} takes closest defender: ${closestDefender.id}`); // Debug
                return closestDefender;
            }
            
            console.log(`⚠️ ${offPlayer.id} found no GOLD target`); // Debug
            return null;
        }

        // Find center target (nose guard first, then gap linebacker)
        function findCenterTarget(center, defensive, playSide) {
            console.log(`🎯 Center (x:${center.x}) looking for target on ${playSide} side play...`); // Debug
            
            // First: Nose guard over center (ON rule)
            const noseGuard = defensive.find(d => 
                Math.abs(d.x - center.x) <= DISTANCE_THRESHOLDS.OVER_PLAYER && d.y < center.y && d.label === 'NG'
            );
            if (noseGuard) {
                console.log(`✅ Center takes nose guard: ${noseGuard.id}`); // Debug
                return noseGuard;
            }
            
            // Second: GOLD Rule - Prioritize PLAYSIDE linebacker first
            const allLBs = defensive.filter(d => 
                (d.label === 'LB' || d.id === 'HYB') && 
                d.y <= 50 // In linebacker level or closer (blitzers move to y:45)
            );
            
            console.log(`🔍 Center found ${allLBs.length} LBs:`, allLBs.map(lb => `${lb.id}(x:${lb.x},y:${lb.y})`)); // Debug
            
            if (allLBs.length > 0) {
                // Separate playside and backside LBs
                const playsideLBs = allLBs.filter(lb => {
                    if (playSide === 'left') {
                        return lb.x <= center.x; // Left side LBs
                    } else {
                        return lb.x >= center.x; // Right side LBs
                    }
                });
                
                const backsideLBs = allLBs.filter(lb => {
                    if (playSide === 'left') {
                        return lb.x > center.x; // Right side LBs
                    } else {
                        return lb.x < center.x; // Left side LBs
                    }
                });
                
                console.log(`🏈 Playside (${playSide}) LBs:`, playsideLBs.map(lb => lb.id)); // Debug
                console.log(`🔄 Backside LBs:`, backsideLBs.map(lb => lb.id)); // Debug
                
                // PRIORITY 1: Closest playside linebacker
                if (playsideLBs.length > 0) {
                    const closestPlaysideLB = playsideLBs.sort((a, b) => 
                        Math.abs(a.x - center.x) - Math.abs(b.x - center.x)
                    )[0];
                    const distance = Math.abs(closestPlaysideLB.x - center.x);
                    
                    if (distance <= 20) {
                        console.log(`✅ Center takes PLAYSIDE LB: ${closestPlaysideLB.id} (${distance} units away)`); // Debug
                        return closestPlaysideLB;
                    }
                }
                
                // PRIORITY 2: Closest backside linebacker (if no playside threat)
                if (backsideLBs.length > 0) {
                    const closestBacksideLB = backsideLBs.sort((a, b) => 
                        Math.abs(a.x - center.x) - Math.abs(b.x - center.x)
                    )[0];
                    const distance = Math.abs(closestBacksideLB.x - center.x);
                    
                    if (distance <= 20) {
                        console.log(`✅ Center takes BACKSIDE LB: ${closestBacksideLB.id} (${distance} units away)`); // Debug
                        return closestBacksideLB;
                    }
                }
            }
            
            // Third: Help playside linebacker if no close threat
            let fallbackLB;
            if (playSide === 'left') {
                fallbackLB = defensive.find(d => d.x <= 50 && (d.label === 'LB' || d.id === 'HYB'));
            } else {
                fallbackLB = defensive.find(d => d.x >= 50 && (d.label === 'LB' || d.id === 'HYB'));
            }
            
            if (fallbackLB) {
                console.log(`⚠️ Center takes fallback LB: ${fallbackLB.id}`); // Debug
            }
            
            return fallbackLB;
        }

        // Find tight end target (avoid doubling with tackles)
        function findTightEndTarget(tePlayer, defensive, side, existingAssignments) {
            // Get list of defenders already assigned
            const assignedDefenders = existingAssignments.map(a => a.to);
            
            // First priority: Man over TE (if not already assigned)
            const manOver = defensive.find(d => 
                Math.abs(d.x - tePlayer.x) <= 8 && 
                d.y < tePlayer.y && 
                !assignedDefenders.includes(d.id)
            );
            if (manOver) return manOver;
            
            // Second priority: Outside linebacker/edge rusher (avoid doubling)
            if (side === 'left') {
                return defensive.find(d => 
                    d.x <= 35 && 
                    (d.label === 'LB' || d.id === 'HYB' || d.label === 'DE') && 
                    !assignedDefenders.includes(d.id)
                );
            } else {
                return defensive.find(d => 
                    d.x >= 65 && 
                    (d.label === 'LB' || d.id === 'HYB' || d.label === 'DE') && 
                    !assignedDefenders.includes(d.id)
                );
            }
        }

        // Find fullback target (prioritize linebackers that OL can't reach)
        function findFullbackTarget(fbPlayer, defensive, side, existingAssignments, targetGap) {
            // FB is a lead blocker - targets unblocked LBs specifically in the running gap
            const assignedDefenders = existingAssignments.map(a => a.to);
            
            // Get the specific gap coordinates
            const gapPosition = getGapPosition(targetGap);
            if (!gapPosition) {
                console.log(`🏃 FB found no valid gap position for gap ${targetGap}`);
                return null;
            }
            
            console.log(`🏃 FB targeting gap ${targetGap} (${side} side) at position x=${gapPosition.x}`);
            console.log(`🏃 Already assigned defenders:`, assignedDefenders);
            
            // Priority 1: Unblocked linebackers in or very close to the specific running gap
            const unblockedLBs = defensive.filter(d => 
                (d.label === 'LB' || d.id === 'HYB') &&
                !assignedDefenders.includes(d.id)
            );
            
            console.log(`🏃 Found ${unblockedLBs.length} unblocked LBs:`, unblockedLBs.map(d => `${d.id}(x:${d.x})`));
            
            if (unblockedLBs.length > 0) {
                // Filter LBs by play direction - FB should only target LBs on the play side or in the gap
                let playSideLBs;
                if (side === 'left') {
                    // Left side play (gaps 1,3,5,7) - target LBs on left side or middle
                    playSideLBs = unblockedLBs.filter(d => d.x <= 65); // Don't go after far right LBs
                } else {
                    // Right side play (gaps 2,4,6) - target LBs on right side or middle  
                    playSideLBs = unblockedLBs.filter(d => d.x >= 35); // Don't go after far left LBs
                }
                
                console.log(`🏃 PlaySide LBs for ${side} side:`, playSideLBs.map(d => `${d.id}(x:${d.x})`));
                
                // For A-gaps (1,2), use tighter targeting since OL handles close LBs
                const isAGap = targetGap === '1' || targetGap === '2';
                const searchDistance = isAGap ? 12 : 15; // Tighter range for A-gaps
                
                // Find LBs within reasonable distance of the specific gap
                const gapAreaLBs = playSideLBs.filter(d => {
                    const distanceToGap = Math.abs(d.x - gapPosition.x);
                    console.log(`🏃 LB ${d.id} at x=${d.x}, distance to gap: ${distanceToGap} (${isAGap ? 'A-gap' : 'other'} - max ${searchDistance})`);
                    
                    // For A-gaps, prefer deeper LBs that guards can't easily reach
                    if (isAGap) {
                        const isDeepEnough = d.y >= 30; // Must be at least 30 units deep
                        return distanceToGap <= searchDistance && isDeepEnough;
                    }
                    
                    return distanceToGap <= searchDistance;
                });
                
                if (gapAreaLBs.length > 0) {
                    // Take the closest LB to the specific gap
                    gapAreaLBs.sort((a, b) => 
                        Math.abs(a.x - gapPosition.x) - Math.abs(b.x - gapPosition.x)
                    );
                    console.log(`🏃 FB lead blocks LB near gap ${targetGap}: ${gapAreaLBs[0].id} (distance: ${Math.abs(gapAreaLBs[0].x - gapPosition.x)})`);
                    return gapAreaLBs[0];
                }
                
                // FALLBACK: If no LB in the gap area, find the next closest unblocked LB on the play side
                console.log(`🏃 No LB in gap ${targetGap} area, looking for next closest LB on ${side} side...`);
                
                if (playSideLBs.length > 0) {
                    // Sort all play-side LBs by distance to gap position
                    playSideLBs.sort((a, b) => 
                        Math.abs(a.x - gapPosition.x) - Math.abs(b.x - gapPosition.x)
                    );
                    
                    console.log(`🏃 FB fallback target: ${playSideLBs[0].id} (distance: ${Math.abs(playSideLBs[0].x - gapPosition.x)} from gap)`);
                    return playSideLBs[0];
                }
                
                console.log(`🏃 FB found no unblocked LBs on ${side} side - no target`);
                return null;
            }
            
            console.log(`🏃 FB found no unblocked LBs - all covered by OL`);
            return null;
        }

        // Get the X coordinate for a specific gap
        function getGapPosition(targetGap) {
            const gapPositions = {
                '1': { x: 42.5 }, // Left A gap (between LG and C)
                '2': { x: 57.5 }, // Right A gap (between C and RG)
                '3': { x: 27.5 }, // Left B gap (between LT and LG) 
                '4': { x: 72.5 }, // Right B gap (between RG and RT)
                '5': { x: 15 },   // Left C gap (outside LT)
                '6': { x: 85 },   // Right C gap (outside RT)
                '7': { x: 10 }    // Far left outside run
            };
            
            return gapPositions[targetGap] || null;
        }

        // Find backside target (cut off pursuit)
        function findBackSideTarget(offPlayer, defensive, side) {
            // Look for closest backside defender to cut off
            if (side === 'left') {
                return defensive.find(d => d.x <= 50 && Math.abs(d.x - offPlayer.x) <= 15);
            } else {
                return defensive.find(d => d.x >= 50 && Math.abs(d.x - offPlayer.x) <= 15);
            }
        }

        // Get block type based on defender
        function getBlockType(defender, offensivePlayer = null, playSide = null) {
            // For linebackers and hybrids, check if they're blitzing (closer than normal)
            if (defender.label === 'LB' || defender.id === 'HYB') {
                // If we have offensive player reference, check distance
                if (offensivePlayer) {
                    const distance = Math.abs(defender.x - offensivePlayer.x);
                    
                    // If LB is very close AND moved forward, treat as gap threat
                    if (distance <= DISTANCE_THRESHOLDS.BLITZ_DETECTION && defender.y >= 40) {
                        console.log(`🚨 ${defender.id} is blitzing! Distance: ${distance}, Y: ${defender.y}, treating as GAP threat`); // Debug
                        return 'gap'; // Blitzing LB is a gap threat
                    }
                }
                return 'linebacker'; // Normal LB assignment
            }
            
            // For defensive linemen - keep it simple
            if (defender.label === 'NG' || defender.label === 'DT' || defender.label === 'DE') {
                return 'on'; // All D-line blocks are "on" blocks
            }
            
            return 'on';
        }

        // Get formation-specific pass protection assignments
        function getFormationSpecificPassProtection(offensive, defensive) {
            const formationType = detectFormationType(defensive);
            console.log(`🛡️ Using ${formationType} pass protection rules`); // Debug
            
            switch (formationType) {
                case '3-4':
                    return get34PassProtection(offensive, defensive);
                case '4-3':
                    return get43PassProtection(offensive, defensive);
                default:
                    // Fallback to generic for other formations
                    return getPassProtectionAssignments(offensive, defensive);
            }
        }

        // 3-4 Defense Pass Protection
        function get34PassProtection(offensive, defensive) {
            const assignments = [];
            console.log('🛡️ Using 3-4 specific pass protection rules');

            // Get offensive players
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');

            // Get 3-4 defensive players
            const de1 = defensive.find(d => d.id === 'DE1');
            const ng = defensive.find(d => d.id === 'NG');
            const de2 = defensive.find(d => d.id === 'DE2');
            const olb1 = defensive.find(d => d.id === 'OLB1');
            const ilb1 = defensive.find(d => d.id === 'ILB1');
            const ilb2 = defensive.find(d => d.id === 'ILB2');
            const olb2 = defensive.find(d => d.id === 'OLB2');

            // 3-4 PASS PROTECTION RULES:
            
            // CENTER: ALWAYS takes Nose Guard (inside gap closest to QB)
            if (center && ng) {
                assignments.push({ from: 'C', to: ng.id, type: 'on' });
                console.log('✅ Center ALWAYS blocks NG in pass pro (closest to QB)');
            }

            // SLIDE PROTECTION: Guards pick up blitzing ILBs, Tackles slide to DEs
            
            // Check for blitzing ILBs (they move from y:25 to y:45 when blitzing)
            const ilb1Blitzing = ilb1 && ilb1.y > 25 && ilb1.y <= 45;
            const ilb2Blitzing = ilb2 && ilb2.y > 25 && ilb2.y <= 45;
            
            // Check if HYB is blitzing (they move from y:25 to y:45 when blitzing)
            const hybridDefender = defensive.find(d => d.id === 'HYB');
            const hybBlitzing = hybridDefender && hybridDefender.y > 25 && hybridDefender.y <= 45;
            
            // Determine which side HYB is on (if present)
            const hybOnLeft = hybridDefender && hybridDefender.x < 50;
            const hybOnRight = hybridDefender && hybridDefender.x >= 50;
            
            // LEFT SIDE: Base vs Slide Protection (include HYB if on left)
            const leftSideBlitz = ilb1Blitzing || (hybBlitzing && hybOnLeft);
            if (leftSideBlitz && leftGuard) {
                if (ilb1Blitzing) {
                    // SLIDE LEFT: LG picks up blitzing ILB1, LT slides to DE1
                    assignments.push({ from: 'LG', to: ilb1.id, type: 'linebacker' });
                    console.log('🚨 SLIDE LEFT: LG picks up blitzing ILB1 in pass pro');
                } else if (hybBlitzing && hybOnLeft) {
                    // SLIDE LEFT: LG picks up blitzing HYB, LT slides to DE1
                    assignments.push({ from: 'LG', to: hybridDefender.id, type: 'linebacker' });
                    console.log('🚨 SLIDE LEFT: LG picks up blitzing HYB in pass pro');
                }
                
                if (leftTackle && de1) {
                    assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                    console.log('🚨 SLIDE LEFT: LT slides to DE1 in pass pro');
                }
            } else {
                // BASE LEFT: Normal assignments
                if (leftGuard && de1) {
                    assignments.push({ from: 'LG', to: de1.id, type: 'on' });
                    console.log('✅ LG blocks DE1 in pass pro (base)');
                }
                
                if (leftTackle && olb1) {
                    assignments.push({ from: 'LT', to: olb1.id, type: 'on' });
                    console.log('✅ LT blocks OLB1 in pass pro (base)');
                }
            }
            
            // RIGHT SIDE: Base vs Slide Protection (include HYB if on right)
            const rightSideBlitz = ilb2Blitzing || (hybBlitzing && hybOnRight);
            if (rightSideBlitz && rightGuard) {
                if (ilb2Blitzing) {
                    // SLIDE RIGHT: RG picks up blitzing ILB2, RT slides to DE2
                    assignments.push({ from: 'RG', to: ilb2.id, type: 'linebacker' });
                    console.log('🚨 SLIDE RIGHT: RG picks up blitzing ILB2 in pass pro');
                } else if (hybBlitzing && hybOnRight) {
                    // SLIDE RIGHT: RG picks up blitzing HYB, RT slides to DE2
                    assignments.push({ from: 'RG', to: hybridDefender.id, type: 'linebacker' });
                    console.log('🚨 SLIDE RIGHT: RG picks up blitzing HYB in pass pro');
                }
                
                if (rightTackle && de2) {
                    assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                    console.log('🚨 SLIDE RIGHT: RT slides to DE2 in pass pro');
                }
            } else {
                // BASE RIGHT: Normal assignments
                if (rightGuard && de2) {
                    assignments.push({ from: 'RG', to: de2.id, type: 'on' });
                    console.log('✅ RG blocks DE2 in pass pro (base)');
                }
                
                if (rightTackle && olb2) {
                    assignments.push({ from: 'RT', to: olb2.id, type: 'on' });
                    console.log('✅ RT blocks OLB2 in pass pro (base)');
                }
            }

            return assignments;
        }

        // 4-3 Defense Pass Protection  
        function get43PassProtection(offensive, defensive) {
            const assignments = [];
            console.log('🛡️ Using 4-3 specific pass protection rules');

            // Get offensive players
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');

            // Get 4-3 defensive players
            const de1 = defensive.find(d => d.id === 'DE1');
            const dt1 = defensive.find(d => d.id === 'DT1');
            const dt2 = defensive.find(d => d.id === 'DT2');
            const de2 = defensive.find(d => d.id === 'DE2');
            const mlb = defensive.find(d => d.id === 'MLB');

            // 4-3 PASS PROTECTION RULES:

            // CENTER: Middle Linebacker - help with A-gap
            if (center && mlb) {
                assignments.push({ from: 'C', to: mlb.id, type: 'linebacker' });
                console.log('✅ Center blocks MLB in pass pro');
            }

            // LEFT GUARD: Defensive Tackle (DT1)
            if (leftGuard && dt1) {
                assignments.push({ from: 'LG', to: dt1.id, type: 'on' });
                console.log('✅ LG blocks DT1 in pass pro');
            }

            // RIGHT GUARD: Defensive Tackle (DT2)
            if (rightGuard && dt2) {
                assignments.push({ from: 'RG', to: dt2.id, type: 'on' });
                console.log('✅ RG blocks DT2 in pass pro');
            }

            // LEFT TACKLE: Defensive End (DE1)
            if (leftTackle && de1) {
                assignments.push({ from: 'LT', to: de1.id, type: 'on' });
                console.log('✅ LT blocks DE1 in pass pro');
            }

            // RIGHT TACKLE: Defensive End (DE2)
            if (rightTackle && de2) {
                assignments.push({ from: 'RT', to: de2.id, type: 'on' });
                console.log('✅ RT blocks DE2 in pass pro');
            }

            return assignments;
        }

        // Get pass protection assignments
        function getPassProtectionAssignments(offensive, defensive) {
            const assignments = [];
            
            // Get offensive players by position
            const center = offensive.find(p => p.id === 'C');
            const leftGuard = offensive.find(p => p.id === 'LG');
            const rightGuard = offensive.find(p => p.id === 'RG');
            const leftTackle = offensive.find(p => p.id === 'LT');
            const rightTackle = offensive.find(p => p.id === 'RT');
            const rightTE = offensive.find(p => p.id === 'RTE');
            
            // PASS PROTECTION RULES:
            // 1. Man over you first
            // 2. Inside gaps must be secure
            // 3. Work inside-out
            
            // CENTER - Nose guard or A-gap help
            if (center) {
                const cTarget = defensive.find(d => 
                    Math.abs(d.x - center.x) <= 10 && d.y < center.y
                ) || defensive.find(d => d.label === 'LB' && Math.abs(d.x - center.x) <= 15);
                
                if (cTarget) assignments.push({ from: 'C', to: cTarget.id, type: 'on' });
            }
            
            // LEFT GUARD - A-gap then B-gap help
            if (leftGuard) {
                const lgTarget = defensive.find(d => 
                    Math.abs(d.x - leftGuard.x) <= 10 && d.y < leftGuard.y
                ) || defensive.find(d => d.x <= 50 && (d.label === 'LB' || d.label === 'DT'));
                
                if (lgTarget) assignments.push({ from: 'LG', to: lgTarget.id, type: 'on' });
            }
            
            // RIGHT GUARD - A-gap then B-gap help  
            if (rightGuard) {
                const rgTarget = defensive.find(d => 
                    Math.abs(d.x - rightGuard.x) <= 10 && d.y < rightGuard.y
                ) || defensive.find(d => d.x >= 50 && (d.label === 'LB' || d.label === 'DT'));
                
                if (rgTarget) assignments.push({ from: 'RG', to: rgTarget.id, type: 'on' });
            }
            
            // LEFT TACKLE - DE or outside rush
            if (leftTackle) {
                const ltTarget = defensive.find(d => 
                    d.x <= 30 && (d.label === 'DE' || d.label === 'OLB')
                ) || defensive.find(d => Math.abs(d.x - leftTackle.x) <= 12 && d.y < leftTackle.y);
                
                if (ltTarget) assignments.push({ from: 'LT', to: ltTarget.id, type: 'on' });
            }
            
            // RIGHT TACKLE - DE or outside rush
            if (rightTackle) {
                const rtTarget = defensive.find(d => 
                    d.x >= 70 && (d.label === 'DE' || d.label === 'OLB')
                ) || defensive.find(d => Math.abs(d.x - rightTackle.x) <= 12 && d.y < rightTackle.y);
                
                if (rtTarget) assignments.push({ from: 'RT', to: rtTarget.id, type: 'on' });
            }
            
            // RIGHT TE - Runs GO ROUTE (no blocking assignment)
            // TE will be visually shown running upfield instead of blocking
            
            return assignments;
        }

        // Add gap labels to the field
        function addGapLabels(field, targetGap) {
            // Based on player positions: LT(20%), LG(35%), C(50%), RG(65%), RT(80%)
            const gaps = [
                { number: '7', x: 10, label: '7 Gap\n(Left D)' },        // Outside LT
                { number: '5', x: 15, label: '5 Gap\n(Left C)' },        // Outside LT 
                { number: '3', x: 27.5, label: '3 Gap\n(Left B)' },      // Between LT(20%) and LG(35%)
                { number: '1', x: 42.5, label: '1 Gap\n(Left A)' },      // Between LG(35%) and C(50%) 
                { number: '2', x: 57.5, label: '2 Gap\n(Right A)' },     // Between C(50%) and RG(65%)
                { number: '4', x: 72.5, label: '4 Gap\n(Right B)' },     // Between RG(65%) and RT(80%)
                { number: '6', x: 85, label: '6 Gap\n(Right C)' },       // Outside RT
                { number: '8', x: 90, label: '8 Gap\n(Right D)' }        // Outside RT
            ];
            
            gaps.forEach(gap => {
                const gapEl = document.createElement('div');
                gapEl.className = 'gap-label';
                gapEl.style.left = `${gap.x}%`;
                gapEl.textContent = gap.number;
                gapEl.title = gap.label;
                gapEl.id = `gap-${gap.number}`;
                
                // Add click listener for gap selection
                gapEl.addEventListener('click', () => selectGapForBlitz(gap.number, gap.x));
                
                // Highlight the target gap for current play
                if (gap.number === targetGap) {
                    gapEl.style.background = '#FF4500';
                    gapEl.style.color = 'white';
                    gapEl.style.fontWeight = 'bold';
                    gapEl.style.transform = 'scale(1.2)';
                    gapEl.style.zIndex = '10';
                }
                
                // Make gaps selectable if LB is selected
                if (selectedLBForBlitz) {
                    gapEl.classList.add('selectable');
                    gapEl.title += '\nClick to send blitzer here!';
                }
                
                field.appendChild(gapEl);
            });
        }

        // Create a player element
        function createPlayer(player, type) {
            const playerEl = document.createElement('div');
            playerEl.className = `player ${type}`;
            playerEl.id = player.id;
            playerEl.style.left = `${player.x}%`;
            playerEl.style.top = `${player.y}%`;
            playerEl.textContent = player.label;
            
            // Add click listeners for all players
            playerEl.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // LB/HYB blitzing takes priority, but only if no offensive player is selected for line drawing
                if ((player.label === 'LB' || player.id === 'HYB') && selectedPlayerForLine === null) {
                    selectLinebackerForBlitz(player.id);
                } else if (manualLineMode) {
                    // All players participate in line drawing when in manual mode
                    selectPlayerForManualLine(player.id, type);
                }
            });
            
            // Add special class for linebackers and hybrid
            if (player.label === 'LB' || player.id === 'HYB') {
                playerEl.classList.add('linebacker');
                if (manualLineMode) {
                    playerEl.title = `${player.label} - Click to draw blocking line`;
                } else {
                    playerEl.title = `${player.label} - Click to select, then click gap to blitz!`;
                }
            } else {
                if (manualLineMode) {
                    playerEl.title = `${player.label} - Click to draw blocking line`;
                } else {
                    playerEl.title = `${player.label} - ${type.includes('offensive') ? 'Offensive' : 'Defensive'}`;
                }
            }
            
            // Update visual state for manual line mode
            if (manualLineMode) {
                playerEl.classList.add('selectable-for-line');
            }
            
            // Update visual state for selected player
            if (selectedPlayerForLine === player.id) {
                playerEl.classList.add('selected-for-line');
            }
            
            return playerEl;
        }

        // Draw blocking assignments
        function drawBlockingAssignments(assignments, offensive, defensive, emphasisLevel = []) {
            const svg = document.getElementById('blocking-lines');
            // Clear all existing lines and arrows
            svg.innerHTML = '';
            
            console.log(`🎨 Drawing ${assignments.length} blocking assignments`); // Debug
            
            assignments.forEach(assignment => {
                const fromPlayer = offensive.find(p => p.id === assignment.from);
                const toPlayer = defensive.find(p => p.id === assignment.to);
                
                if (fromPlayer && toPlayer) {
                    // Skip FB assignments unless FB is highlighted
                    if (assignment.from === 'FB' && !isFBHighlighted()) {
                        return; // Don't draw FB lines unless FB is highlighted
                    }
                    
                    const isEmphasized = emphasisLevel.includes(assignment.type);
                    drawAssignmentLine(svg, fromPlayer, toPlayer, isEmphasized, assignment);
                }
            });
        }

        // Check if FB is currently highlighted
        function isFBHighlighted() {
            const fbPlayer = document.getElementById('FB');
            const isHighlighted = fbPlayer && fbPlayer.classList.contains('highlighted');
            console.log(`🏃 FB highlighted check: FB element exists=${!!fbPlayer}, highlighted=${isHighlighted}`);
            return isHighlighted;
        }

        // Draw a single assignment line
        function drawAssignmentLine(svg, from, to, isEmphasized = false, assignment = null) {
            // Check if this is a TE going around a DE to block a LB
            if ((from.id === 'LTE' || from.id === 'RTE') && to.label === 'LB') {
                drawTEBlockingPath(svg, from, to, isEmphasized);
                return;
            }
            
            // Check if this is a FB going around linemen to block a LB
            if (from.id === 'FB' && (to.label === 'LB' || to.id === 'HYB')) {
                drawFBBlockingPath(svg, from, to, isEmphasized);
                return;
            }
            
            const fieldRect = document.getElementById('field').getBoundingClientRect();
            const fromX = (from.x / 100) * fieldRect.width;
            const fromY = (from.y / 100) * fieldRect.height;
            const toX = (to.x / 100) * fieldRect.width;
            const toY = (to.y / 100) * fieldRect.height;
            
            // Create line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromX);
            line.setAttribute('y1', fromY);
            line.setAttribute('x2', toX);
            line.setAttribute('y2', toY);
            
            // Determine line style based on player type
            let lineClass = 'assignment-line';
            if (from.id === 'FB') {
                // FB gets transparent purple line
                lineClass = 'assignment-line fullback';
            } else if (isEmphasized) {
                lineClass = 'assignment-line emphasis';
            }
            
            line.setAttribute('class', lineClass);
            
            // No arrow head - just clean lines
            svg.appendChild(line);
        }

        // Draw TE blocking path around DE to get to LB
        function drawTEBlockingPath(svg, tePlayer, linebacker, isEmphasized = false) {
            const fieldRect = document.getElementById('field').getBoundingClientRect();
            const teBaseX = (tePlayer.x / 100) * fieldRect.width;
            const teBaseY = (tePlayer.y / 100) * fieldRect.height;
            const toX = (linebacker.x / 100) * fieldRect.width;
            const toY = (linebacker.y / 100) * fieldRect.height;
            
            // Start from correct edge of TE circle
            const isLeftTE = tePlayer.x < 50;
            const circleRadius = 20; // Player circle radius
            const fromX = isLeftTE ? teBaseX - circleRadius : teBaseX + circleRadius;
            const fromY = teBaseY;
            const pathOffset = 25; // How far around the DE to go
            
            // Calculate control points for curved path
            let controlX1, controlY1, controlX2, controlY2;
            
            if (isLeftTE) {
                // Left TE goes around left side of DE
                controlX1 = fromX - pathOffset;
                controlY1 = fromY - 15;
                controlX2 = toX - 20;
                controlY2 = toY + 10;
            } else {
                // Right TE goes around right side of DE
                controlX1 = fromX + pathOffset;
                controlY1 = fromY - 15;
                controlX2 = toX + 20;
                controlY2 = toY + 10;
            }
            
            // Create curved path using SVG path element
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', isEmphasized ? '#FF4500' : '#FFD700');
            path.setAttribute('stroke-width', isEmphasized ? '6' : '4');
            path.setAttribute('stroke-dasharray', isEmphasized ? '15, 5' : '10, 5');
            path.setAttribute('class', isEmphasized ? 'assignment-line emphasis' : 'assignment-line');
            
            // No arrow head - just clean curved path
            svg.appendChild(path);
        }

        // Draw FB blocking path under the guard level then up to linebacker
        function drawFBBlockingPath(svg, fbPlayer, linebacker, isEmphasized = false) {
            const fieldRect = document.getElementById('field').getBoundingClientRect();
            const fbBaseX = (fbPlayer.x / 100) * fieldRect.width;
            const fbBaseY = (fbPlayer.y / 100) * fieldRect.height;
            const toX = (linebacker.x / 100) * fieldRect.width;
            const toY = (linebacker.y / 100) * fieldRect.height;
            
            // FB starts from the FB position, goes under the guard level
            const circleRadius = 20; // Player circle radius
            const fromX = fbBaseX;
            const fromY = fbBaseY; // Start from center of FB circle
            
            // Determine which side to go around based on LB position
            const isLBOnLeft = linebacker.x < 50;
            const backfieldDepth = 25; // How far back behind LOS to go
            const sideOffset = 35; // How far to the side to go
            
            // Calculate control points for path: back behind LOS, then forward to LB
            let controlX1, controlY1, controlX2, controlY2;
            
            if (isLBOnLeft) {
                // LB is on left side - FB goes back, left, then forward
                controlX1 = fromX - sideOffset; // Go left
                controlY1 = fromY + backfieldDepth; // Go back behind LOS (deeper)
                controlX2 = toX - 15; // Approach LB from slightly behind
                controlY2 = toY + 10;
            } else {
                // LB is on right side - FB goes back, right, then forward  
                controlX1 = fromX + sideOffset; // Go right
                controlY1 = fromY + backfieldDepth; // Go back behind LOS (deeper)
                controlX2 = toX + 15; // Approach LB from slightly behind
                controlY2 = toY + 10;
            }
            
            // Create curved path using SVG path element
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'rgba(138, 43, 226, 0.6)'); // Transparent purple for FB
            path.setAttribute('stroke-width', '3');
            path.setAttribute('stroke-dasharray', '5, 3');
            path.setAttribute('class', 'assignment-line fullback');
            
            // No arrow head - just clean curved path
            svg.appendChild(path);
        }

        // Update explanation text with play type info
        function updateExplanationWithPlayType(explanationData, playData) {
            const explanation = document.getElementById('explanation');
            
            // Different colors for different play emphasis
            let panelColor;
            if (playData.emphasisLevel.includes('gap')) {
                panelColor = 'background: linear-gradient(45deg, #ffc107, #ffb300);'; // Golden yellow for gap emphasis
            } else if (playData.targetGap === 'pass') {
                panelColor = 'background: linear-gradient(45deg, #17b8be, #20d0d7);'; // Teal for pass pro
            } else {
                panelColor = 'background: linear-gradient(45deg, #ffc107, #ffb300);'; // Default golden yellow
            }
            
            explanation.innerHTML = `
                <div style="${panelColor} color: black; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #FFD700; box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);">
                    <h3 style="margin: 0 0 10px 0; color: black;">🎯 ${playData.name} Focus:</h3>
                    <p style="margin: 0; font-size: 1.1em; font-weight: bold;">${playData.emphasis}</p>
                    <p style="margin: 5px 0 0 0; font-style: italic;">${playData.description}</p>
                </div>
                <h3>${explanationData.title}</h3>
                <ul>
                    ${explanationData.points.map(point => `<li>${point}</li>`).join('')}
                </ul>
            `;
        }

        // Highlight specific positions
        function highlightPosition(position) {
            console.log(`🎯 Highlighting position: ${position}`);
            
            // Special handling for FB - check if it exists (only on run plays)
            if (position === 'FB') {
                const currentPlay = playTypes[currentPlayType];
                if (currentPlay.targetGap === 'pass') {
                    console.log(`❌ FB not available on pass plays`);
                    alert('Fullback is only available on run plays (gaps 1-4), not pass protection.');
                    return;
                }
            }
            
            // Check if this position is currently highlighted (for toggle behavior)
            const wasHighlighted = position === 'FB' ? 
                document.getElementById('FB')?.classList.contains('highlighted') : false;
            
            // Clear existing highlights
            document.querySelectorAll('.player').forEach(player => {
                player.classList.remove('highlighted');
            });
            
            // Apply new highlights - now individual positions (but skip if it was already highlighted - toggle behavior)
            if (!wasHighlighted) {
                const positions = {
                    'TE': ['LTE', 'RTE'], // Single TE button highlights whichever TE is present
                    'FB': ['FB'], // Fullback
                    'LT': ['LT'],
                    'LG': ['LG'],
                    'C': ['C'],
                    'RG': ['RG'],
                    'RT': ['RT']
                };
                
                if (positions[position]) {
                    positions[position].forEach(pos => {
                        const player = document.getElementById(pos);
                        console.log(`🎯 Looking for player ${pos}: found=${!!player}`);
                        if (player) {
                            player.classList.add('highlighted');
                            console.log(`✅ Highlighted ${pos}, classes now: ${player.className}`);
                            
                            // Double-check immediately after adding
                            const hasHighlight = player.classList.contains('highlighted');
                            console.log(`🔍 Double-check ${pos} highlighted: ${hasHighlight}`);
                        } else {
                            console.log(`❌ Player ${pos} not found`);
                        }
                    });
                }
            } else {
                console.log(`🔄 ${position} was already highlighted - toggling off`);
            }
            
            // If FB was highlighted/unhighlighted, redraw just the blocking lines to show/hide FB assignments
            if (position === 'FB' && showAssignmentLines) {
                console.log(`🔄 FB highlight changed, redrawing blocking lines only`);
                
                // Get current assignments and redraw just the lines
                const data = formations[currentFormation];
                const playData = playTypes[currentPlayType];
                
                // Get all offensive players including TE and FB
                const allOffensive = [...data.offensive];
                const tightEnd = addTightEnd(playData.side, playData.targetGap);
                const fullback = addFullback(playData.side, playData.targetGap);
                
                if (tightEnd) allOffensive.push(tightEnd);
                if (fullback) allOffensive.push(fullback);
                
                // Get current defensive setup
                let allDefensive = [...data.defensive];
                if (tightEnd) {
                    const hybridDefender = createHybridDefender(playData.side);
                    if (hybridDefender) allDefensive.push(hybridDefender);
                }
                
                // Get assignments and redraw
                const assignments = getPlayDirectionAssignments(allOffensive, allDefensive, playData.side, playData.targetGap);
                drawBlockingAssignments(assignments, allOffensive, allDefensive, ['gap', 'on']);
            }
        }

        // Select linebacker for blitz movement
        function selectLinebackerForBlitz(linebackerId) {
            console.log(`🎯 Selecting LB/HYB for blitz: ${linebackerId}`); // Debug
            
            // If this LB is already blitzing, stop the blitz
            if (blitzingLinebackers.has(linebackerId)) {
                console.log(`🔄 ${linebackerId} already blitzing - removing`); // Debug
                blitzingLinebackers.delete(linebackerId);
                
                // Clear custom blitz position for this LB/HYB
                if (window.customBlitzPositions && window.customBlitzPositions.has(linebackerId)) {
                    window.customBlitzPositions.delete(linebackerId);
                    console.log(`🗑️ Cleared custom position for ${linebackerId}`); // Debug
                }
                
                // Recalculate assignments for remaining blitzing LBs
                selectedLBForBlitz = null;
                
                // If there are still blitzing LBs, update assignments; otherwise reset to original
                if (blitzingLinebackers.size > 0) {
                    console.log(`🔄 Recalculating assignments for remaining blitzing LBs:`, Array.from(blitzingLinebackers)); // Debug
                    updateBlockingAssignmentsForBlitz();
                } else {
                    console.log(`🔄 No LBs blitzing - reset to original scheme`); // Debug
                    window.updatedAssignments = null;
                }
                
                renderFormation(currentFormation, currentPlayType);
                return;
            }
            
            // Clear previous selection
            document.querySelectorAll('.linebacker.selected').forEach(lb => {
                lb.classList.remove('selected');
            });
            
            // Select this linebacker
            selectedLBForBlitz = linebackerId;
            console.log(`✅ Selected ${linebackerId} for blitz`); // Debug
            const lbElement = document.getElementById(linebackerId);
            if (lbElement) {
                lbElement.classList.add('selected');
            }
            
            // Re-render to show gap selection options
            renderFormation(currentFormation, currentPlayType);
        }

        // Select gap for the selected linebacker to blitz to
        function selectGapForBlitz(gapNumber, gapX) {
            if (!selectedLBForBlitz) {
                alert('Please select a linebacker first!');
                return;
            }
            
            console.log(`🎯 Moving ${selectedLBForBlitz} to gap ${gapNumber} at x:${gapX}`); // Debug
            
            // Store the blitz position
            blitzingLinebackers.add(selectedLBForBlitz);
            console.log(`✅ Added ${selectedLBForBlitz} to blitzing set`); // Debug
            
            // Store custom blitz position
            if (!window.customBlitzPositions) {
                window.customBlitzPositions = new Map();
            }
            window.customBlitzPositions.set(selectedLBForBlitz, { x: gapX, y: 45 });
            console.log(`✅ Stored custom position for ${selectedLBForBlitz}:`, { x: gapX, y: 45 }); // Debug
            
            // Clear selection
            selectedLBForBlitz = null;
            
            // AUTO-UPDATE: Recalculate blocking assignments with new LB position
            updateBlockingAssignmentsForBlitz();
            
            // Re-render to show the blitz and updated assignments
            renderFormation(currentFormation, currentPlayType);
        }

        // Update blocking assignments when linebacker blitzes into gap
        function updateBlockingAssignmentsForBlitz() {
            if (!showAssignmentLines) return; // Don't update if lines are hidden
            
            console.log('🔄 Updating assignments for blitz...'); // Debug
            
            // Get current play data
            const playData = playTypes[currentPlayType];
            const data = formations[currentFormation];
            
            // Start with original defensive players
            let updatedDefensive = data.defensive.map(defender => {
                if (blitzingLinebackers.has(defender.id) && window.customBlitzPositions && window.customBlitzPositions.has(defender.id)) {
                    const blitzPos = window.customBlitzPositions.get(defender.id);
                    console.log(`Moving ${defender.id} to x:${blitzPos.x}, y:${blitzPos.y}`); // Debug
                    return {
                        ...defender,
                        x: blitzPos.x,
                        y: blitzPos.y
                    };
                }
                return defender;
            });
            
            // Add HYB defender if present (from strong side)
            const tightEnd = addTightEnd(playData.side, playData.targetGap);
            if (tightEnd) {
                const hybridDefender = createHybridDefender(playData.side);
                if (hybridDefender) {
                    console.log(`🎯 HYB Defender created: ${hybridDefender.id}`); // Debug
                    console.log(`🎯 Blitzing LBs:`, Array.from(blitzingLinebackers)); // Debug
                    console.log(`🎯 Custom positions:`, window.customBlitzPositions ? Array.from(window.customBlitzPositions.keys()) : 'none'); // Debug
                    
                    // Check if HYB is blitzing
                    if (blitzingLinebackers.has(hybridDefender.id) && window.customBlitzPositions && window.customBlitzPositions.has(hybridDefender.id)) {
                        const blitzPos = window.customBlitzPositions.get(hybridDefender.id);
                        console.log(`🚨 Moving HYB to x:${blitzPos.x}, y:${blitzPos.y}`); // Debug
                        hybridDefender.x = blitzPos.x;
                        hybridDefender.y = blitzPos.y;
                    } else {
                        console.log(`🔍 HYB not blitzing - keeping original position`); // Debug
                    }
                    updatedDefensive.push(hybridDefender);
                    console.log(`✅ Included HYB in assignment calculations`); // Debug
                }
            }
            
            console.log('Updated defensive:', updatedDefensive); // Debug
            
            // Get all offensive players including TE and FB
            const allOffensive = [...data.offensive];
            if (tightEnd) allOffensive.push(tightEnd);
            
            // Add fullback if present for run plays
            const fullback = addFullback(playData.side, playData.targetGap);
            if (fullback) allOffensive.push(fullback);
            
            // Recalculate blocking assignments with updated positions
            const newAssignments = getPlayDirectionAssignments(
                allOffensive, 
                updatedDefensive, 
                playData.side, 
                playData.targetGap
            );
            
            console.log('New assignments:', newAssignments); // Debug
            const originalAssignments = getPlayDirectionAssignments(
                allOffensive, 
                data.defensive, 
                playData.side, 
                playData.targetGap
            );
            console.log('Original assignments would be:', originalAssignments); // Debug
            
            // Compare assignments to see differences
            const differences = [];
            newAssignments.forEach((newAssign, index) => {
                const originalAssign = originalAssignments[index];
                if (originalAssign && (newAssign.to !== originalAssign.to || newAssign.type !== originalAssign.type)) {
                    differences.push({
                        player: newAssign.from,
                        was: `${originalAssign.to} (${originalAssign.type})`,
                        now: `${newAssign.to} (${newAssign.type})`
                    });
                }
            });
            
            if (differences.length > 0) {
                console.log('🔄 Assignment changes detected:', differences);
            } else {
                console.log('⚠️ No assignment changes - blitz may not be close enough to affect blocking');
            }
            
            // Store the updated assignments for rendering
            window.updatedAssignments = newAssignments;
        }

        // Get blitz position for a linebacker (now uses custom positions)
        function getBlitzPosition(lbPlayer) {
            if (window.customBlitzPositions && window.customBlitzPositions.has(lbPlayer.id)) {
                return window.customBlitzPositions.get(lbPlayer.id);
            }
            
            // Fallback to random position (shouldn't happen with new system)
            return { x: lbPlayer.x, y: 45 };
        }

        // Toggle assignment lines on/off


        // Toggle between automatic lines and manual drawing mode
        function toggleLineMode() {
            if (!manualLineMode) {
                // Switch to manual mode: hide automatic lines, enable drawing
                manualLineMode = true;
                showAssignmentLines = false;
                selectedPlayerForLine = null;
                
                const btn = document.getElementById('line-mode-toggle');
                btn.textContent = 'Show Lines';
                btn.style.background = 'linear-gradient(45deg, #6f42c1, #5a32a3)';
                
                console.log('🎨 Manual line drawing mode enabled'); // Debug
            } else {
                // Switch to automatic mode: show automatic lines, disable drawing, clear manual lines
                manualLineMode = false;
                showAssignmentLines = true;
                selectedPlayerForLine = null;
                manualLines = []; // Clear all manual lines
                
                const btn = document.getElementById('line-mode-toggle');
                btn.textContent = 'Draw Lines';
                btn.style.background = 'linear-gradient(45deg, #28a745, #20c997)';
                
                console.log('📋 Automatic assignment lines enabled'); // Debug
            }
            
            // Re-render to update display
            renderFormation(currentFormation, currentPlayType);
        }

        // Select player for manual line drawing
        function selectPlayerForManualLine(playerId, playerType) {
            if (!manualLineMode) return;
            
            console.log('Manual line click:', playerId, playerType); // Debug
            
            if (selectedPlayerForLine === null) {
                // First click - select offensive player
                if (playerType.includes('offensive')) {
                    selectedPlayerForLine = playerId;
                    const player = document.getElementById(playerId);
                    if (player) {
                        player.classList.add('selected-for-line');
                        console.log('Selected offensive player:', playerId); // Debug
                    }
                } else {
                    console.log('Click offensive player first!'); // Debug
                }
            } else if (selectedPlayerForLine === playerId) {
                // Click same player - deselect
                selectedPlayerForLine = null;
                const player = document.getElementById(playerId);
                if (player) {
                    player.classList.remove('selected-for-line');
                    console.log('Deselected player:', playerId); // Debug
                }
            } else {
                // Second (or subsequent) click - handle defensive player
                if (playerType.includes('defensive')) {
                    // Check for any line that ends at this defender from our selected OL chain
                    const directLineIndex = manualLines.findIndex(line => 
                        line.from === selectedPlayerForLine && line.to === playerId
                    );
                    
                    // Also check for combo block line (from another defender to this one)
                    const comboLineIndex = manualLines.findIndex(line => 
                        line.to === playerId && manualLines.some(parentLine => 
                            parentLine.from === selectedPlayerForLine && parentLine.to === line.from
                        )
                    );
                    
                    if (directLineIndex !== -1) {
                        // Direct line exists - remove it and any subsequent combo
                        const subsequentComboIndex = manualLines.findIndex(line => line.from === playerId);
                        if (subsequentComboIndex !== -1) {
                            manualLines.splice(subsequentComboIndex, 1);
                            console.log('Removed subsequent combo from', playerId); // Debug
                        }
                        manualLines.splice(directLineIndex, 1);
                        console.log('Removed direct line from', selectedPlayerForLine, 'to', playerId); // Debug
                        
                        // Clear selection
                        const selectedPlayer = document.getElementById(selectedPlayerForLine);
                        if (selectedPlayer) {
                            selectedPlayer.classList.remove('selected-for-line');
                        }
                        selectedPlayerForLine = null;
                    } else if (comboLineIndex !== -1) {
                        // Combo line exists - remove just the combo part
                        manualLines.splice(comboLineIndex, 1);
                        console.log('Removed combo line to', playerId); // Debug
                        
                        // Keep OL selected for potential new combo
                        console.log('OL', selectedPlayerForLine, 'still selected'); // Debug
                    } else {
                        // Find if there's already a line from this offensive player
                        const existingFromOL = manualLines.find(line => line.from === selectedPlayerForLine);
                        
                        if (existingFromOL) {
                            // Check if we already have a chain (max 2 lines per OL)
                            const existingChain = manualLines.find(line => line.from === existingFromOL.to);
                            
                            if (existingChain) {
                                console.log('Max 2 combo blocks per player reached!'); // Debug
                                return; // Don't allow more than 2 lines
                            }
                            
                            // There's already a line from OL to another defender
                            // Create a chained line from that defender to this new defender
                            manualLines.push({
                                from: existingFromOL.to,  // From the previous defender
                                to: playerId              // To this new defender
                            });
                            console.log('Created combo block from', existingFromOL.to, 'to', playerId); // Debug
                        } else {
                            // No existing line - create new line from OL to defender
                            manualLines.push({
                                from: selectedPlayerForLine,
                                to: playerId
                            });
                            console.log('Created line from', selectedPlayerForLine, 'to', playerId); // Debug
                        }
                        
                        // Keep the offensive player selected for potential next defender
                        console.log('OL', selectedPlayerForLine, 'still selected for next combo block'); // Debug
                    }
                    
                    // Re-render to show the line
                    renderFormation(currentFormation, currentPlayType);
                } else {
                    console.log('Click defensive player to complete line!'); // Debug
                }
            }
        }

        // Draw manual lines
        // Draw TE route for pass protection
        function drawTERoute(tePlayer) {
            const svg = document.getElementById('blocking-lines');
            const field = document.getElementById('field');
            const fieldRect = field.getBoundingClientRect();
            
            // Start from TE's outside edge of circle
            const teBaseX = (tePlayer.x / 100) * fieldRect.width;
            const teBaseY = (tePlayer.y / 100) * fieldRect.height;
            
            // Determine if TE is on left or right side and start from correct edge
            const isLeftTE = tePlayer.x < 50;
            const circleRadius = 20; // Player circle radius
            const startX = isLeftTE ? teBaseX - circleRadius : teBaseX + circleRadius;
            const startY = teBaseY;
            
            // Route runs straight upfield, well past linebackers (LBs are around y=25%)
            const endX = startX; // Straight line
            const endY = startY - 140; // Extend well past LBs
            
            // Create route line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#17b8be'); // Teal for route
            line.setAttribute('stroke-width', '4');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('class', 'te-route');
            
            // Create route arrow at the end
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            const arrowSize = 8;
            const arrowPoints = `${endX},${endY} ${endX-arrowSize},${endY+arrowSize*2} ${endX+arrowSize},${endY+arrowSize*2}`;
            arrow.setAttribute('points', arrowPoints);
            arrow.setAttribute('fill', '#17b8be');
            arrow.setAttribute('class', 'te-route-arrow');
            
            svg.appendChild(line);
            svg.appendChild(arrow);
        }

        function drawManualLines() {
            if (manualLines.length === 0) return;
            
            const svg = document.getElementById('blocking-lines');
            const field = document.getElementById('field');
            
            manualLines.forEach(line => {
                const fromPlayer = document.getElementById(line.from);
                const toPlayer = document.getElementById(line.to);
                
                if (fromPlayer && toPlayer) {
                    const fieldRect = field.getBoundingClientRect();
                    const fromX = (parseFloat(fromPlayer.style.left) / 100) * fieldRect.width;
                    const fromY = (parseFloat(fromPlayer.style.top) / 100) * fieldRect.height;
                    const toX = (parseFloat(toPlayer.style.left) / 100) * fieldRect.width;
                    const toY = (parseFloat(toPlayer.style.top) / 100) * fieldRect.height;
                    
                    // Create line
                    const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    lineEl.setAttribute('x1', fromX);
                    lineEl.setAttribute('y1', fromY);
                    lineEl.setAttribute('x2', toX);
                    lineEl.setAttribute('y2', toY);
                    lineEl.setAttribute('stroke', '#FF4500');
                    lineEl.setAttribute('stroke-width', '5');
                    lineEl.setAttribute('stroke-dasharray', '10, 5');
                    lineEl.style.filter = 'drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3))';
                    
                    // Create arrow
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    const arrowLength = 12;
                    const arrowAngle = 0.5;
                    
                    const arrowX1 = toX - arrowLength * Math.cos(angle - arrowAngle);
                    const arrowY1 = toY - arrowLength * Math.sin(angle - arrowAngle);
                    const arrowX2 = toX - arrowLength * Math.cos(angle + arrowAngle);
                    const arrowY2 = toY - arrowLength * Math.sin(angle + arrowAngle);
                    
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    arrow.setAttribute('points', `${toX},${toY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
                    arrow.setAttribute('fill', '#FF4500');
                    arrow.style.filter = 'drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3))';
                    
                    svg.appendChild(lineEl);
                    svg.appendChild(arrow);
                }
            });
        }

        // Clean up global state
        function cleanupGlobalState() {
            // Clear blitz data
            blitzingLinebackers.clear();
            selectedLBForBlitz = null;
            
            // Clear custom positions
            if (window.customBlitzPositions) {
                window.customBlitzPositions.clear();
            }
            
            // Clear updated assignments
            window.updatedAssignments = null;
            
            // Clear manual lines
            manualLines = [];
            selectedPlayerForLine = null;
            
            console.log('🧹 Global state cleaned up');
        }

        // Reset everything to clean state
        // Create Hybrid defender on strong side (where TE is)
        function createHybridDefender(tightEndSide) {
            if (!tightEndSide) return null; // No TE, no hybrid
            
            let x, y;
            
            if (tightEndSide === 'left') {
                // Hybrid on left side (7 hole) - 4 cells further out from OLB1
                x = 6;
                y = 25; // Same level as linebackers
            } else {
                // Hybrid on right side (8 hole) - 4 cells further out from OLB2
                x = 94;
                y = 25; // Same level as linebackers
            }
            
            return {
                id: 'HYB',
                x: x,
                y: y,
                label: 'HYB',
                side: tightEndSide
            };
        }
        
        function resetAll() {
            // Clear highlights
            document.querySelectorAll('.player').forEach(player => {
                player.classList.remove('highlighted');
            });
            
            // Clear blitzers
            blitzingLinebackers.clear();
            selectedLBForBlitz = null;
            if (window.customBlitzPositions) {
                window.customBlitzPositions.clear();
            }
            
            // Clear updated assignments
            window.updatedAssignments = null;
            
            // Clear manual lines
            manualLines = [];
            selectedPlayerForLine = null;
            

            
            // Turn off manual line mode
            manualLineMode = false;
            showAssignmentLines = true;
            const lineToggleBtn = document.getElementById('line-mode-toggle');
            if (lineToggleBtn) {
                lineToggleBtn.textContent = 'Draw Lines';
                lineToggleBtn.style.background = 'linear-gradient(45deg, #28a745, #20c997)';
            }
            
            // Clear all player states
            document.querySelectorAll('.linebacker').forEach(lb => {
                lb.classList.remove('blitzing', 'selected');
            });
            document.querySelectorAll('.selected-for-line').forEach(player => {
                player.classList.remove('selected-for-line');
            });
            
            // Re-render to restore clean state
            renderFormation(currentFormation, currentPlayType);
        }

        // Toggle tutorial tooltip
        function toggleTutorial() {
            const tooltip = document.getElementById('tutorialTooltip');
            tooltip.classList.toggle('show');
        }

        // Close tutorial when clicking outside
        document.addEventListener('click', function(event) {
            const tutorialContainer = document.querySelector('.tutorial-container');
            const tooltip = document.getElementById('tutorialTooltip');
            
            if (tooltip && tooltip.classList.contains('show')) {
                // Check if click is outside the tutorial container
                if (!tutorialContainer.contains(event.target)) {
                    tooltip.classList.remove('show');
                }
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            setTimeout(() => {
                renderFormation(currentFormation, currentPlayType);
            }, 100);
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
